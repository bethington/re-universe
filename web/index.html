<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BSim Analysis Portal</title>
    <style>
        :root {
            /* Dark theme base - inspired by D2's dark UI */
            --bg-darkest: #0a0a0c;
            --bg-dark: #111114;
            --bg-medium: #1a1a1f;
            --bg-light: #222228;
            --bg-hover: #2a2a32;
            --border-dark: #2d2d35;
            --border-light: #3d3d45;

            /* D2 Item Rarity Colors */
            --color-normal: #c0c0c0;
            --color-magic: #6969FF;
            --color-rare: #FFFF00;
            --color-unique: #C7B377;
            --color-set: #00FF00;
            --color-crafted: #FF6600;
            --color-runeword: #BDA461;

            /* Semantic colors */
            --text-primary: #d4d4d4;
            --text-secondary: #8b8b8b;
            --text-muted: #5a5a5a;
            --accent-gold: #C7B377;
            --accent-red: #8b2020;
            --accent-red-light: #c93030;

            /* Fonts */
            --font-main: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-darkest);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-medium) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--accent-red);
            padding: 0.6rem 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-gold);
            letter-spacing: 0.5px;
        }

        .header-search {
            margin-left: auto;
            position: relative;
        }

        .header-search input {
            padding: 0.4rem 0.8rem 0.4rem 2rem;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
            width: 280px;
            font-family: var(--font-mono);
        }

        .header-search::before {
            content: "⌕";
            position: absolute;
            left: 0.6rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .header-search input::placeholder {
            color: var(--text-muted);
        }

        .header-search input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        /* Main three-panel layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            gap: 1px;
            background-color: var(--bg-darkest);
        }

        .panels-wrapper {
            display: flex;
            flex: 1;
            gap: 1px;
            background-color: var(--border-dark);
            height: 100%;
            min-width: 0;
            overflow: hidden;
        }

        /* Panel base styles */
        .panel {
            background-color: var(--bg-dark);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        .panel-header {
            padding: 0.6rem 0.8rem;
            background: linear-gradient(180deg, var(--bg-light) 0%, var(--bg-medium) 100%);
            border-bottom: 1px solid var(--border-dark);
            flex-shrink: 0;
        }

        .panel-header h2 {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-header-files {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-header-files .files-filter {
            margin-left: auto;
            padding: 0.2rem 0.4rem;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.7rem;
            width: 100px;
        }

        .panel-header-files .files-filter:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .panel-details .panel-content {
            overflow: hidden;
        }

        /* Panel 1: Version Navigator */
        .panel-versions {
            width: 70px;
            flex-shrink: 0;
        }

        .version-filters {
            display: flex;
            gap: 0.25rem;
            padding: 0.35rem;
            border-bottom: 1px solid var(--border-dark);
        }

        .filter-buttons {
            display: flex;
            gap: 0.2rem;
        }

        .filter-btn {
            flex: 1;
            padding: 0.25rem 0.2rem;
            font-size: 0.55rem;
            font-weight: 600;
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            min-width: 0;
        }

        /* Pre-Refactor Classic (1.00-1.03) - old codebase */
        .filter-btn.pre-refactor {
            background: linear-gradient(180deg, #2a1010 0%, #150505 100%);
            color: #cc4444;
        }

        /* Post-Refactor Classic (1.04+) - modern codebase */
        .filter-btn.post-refactor {
            background: linear-gradient(180deg, #2a1a1a 0%, #1a0a0a 100%);
            color: #ff6666;
        }

        /* LoD - all LoD versions */
        .filter-btn.lod {
            background: linear-gradient(180deg, #2a2a1a 0%, #1a1a0a 100%);
            color: var(--accent-gold);
        }

        .filter-btn.active {
            border-color: currentColor;
            box-shadow: 0 0 4px currentColor;
        }

        .filter-btn:not(.active) {
            opacity: 0.4;
        }

        .filter-btn:hover {
            opacity: 1;
        }

        .version-list {
            padding: 0.25rem 0;
        }

        .version-item {
            display: flex;
            align-items: center;
            padding: 0.3rem 0.4rem;
            cursor: pointer;
            transition: background-color 0.1s;
            gap: 0.3rem;
        }

        .version-item:hover {
            background-color: var(--bg-hover);
        }

        .version-item.selected {
            background-color: var(--bg-light);
            border-left: 2px solid var(--accent-gold);
            padding-left: calc(0.4rem - 2px);
        }

        .version-badge {
            font-size: 0.7rem;
            font-weight: 600;
            width: 100%;
            text-align: center;
        }

        .version-badge.classic {
            color: #ff6666;
        }

        .version-badge.lod {
            color: var(--accent-gold);
        }

        .version-type {
            font-size: 0.6rem;
            font-weight: 700;
            width: 14px;
            text-align: center;
            opacity: 0.7;
        }

        .version-type.classic {
            color: #ff6666;
        }

        .version-type.lod {
            color: var(--accent-gold);
        }

        .file-counts {
            font-size: 0.65rem;
            font-family: var(--font-mono);
            color: var(--text-muted);
            min-width: 36px;
            text-align: right;
            white-space: nowrap;
        }

        .file-counts .changed {
            color: var(--color-set);
        }

        .file-counts .separator {
            color: var(--text-muted);
            opacity: 0.5;
        }

        .file-counts .total {
            color: var(--text-muted);
        }

        /* Panel 2: Files */
        .panel-files {
            flex: 0 1 auto;
            min-width: 200px;
            max-width: none;
        }

        .files-toolbar {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background-color: var(--bg-medium);
            border-bottom: 1px solid var(--border-dark);
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .category-filters {
            display: flex;
            gap: 0.2rem;
            flex-wrap: wrap;
            flex: 1;
            justify-content: flex-start;
        }

        .category-btn {
            padding: 0.2rem 0.4rem;
            font-size: 0.6rem;
            font-weight: 600;
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            background-color: var(--bg-dark);
            white-space: nowrap;
        }

        .category-btn .full-text {
            display: none;
        }

        .category-btn .short-text {
            display: inline;
        }

        .category-btn.active {
            border-color: currentColor;
            box-shadow: 0 0 3px currentColor;
        }

        .category-btn:not(.active) {
            opacity: 0.35;
        }

        .group-btn {
            padding: 0.2rem 0.5rem;
            font-size: 0.65rem;
            font-weight: 600;
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            background-color: var(--bg-dark);
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .group-btn .full-text {
            display: none;
        }

        .group-btn .short-text {
            display: inline;
        }

        .group-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .group-btn.active {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background-color: rgba(199, 179, 119, 0.1);
        }

        .files-table {
            display: grid;
            grid-template-columns: auto 1fr auto;
            position: relative;
            width: 100%;
            min-width: 200px;
        }

        .table-header {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: subgrid;
            align-items: center;
            padding: 0.3rem 0.6rem;
            background-color: var(--bg-medium);
            border-bottom: 1px solid var(--border-dark);
            position: sticky;
            top: 0;
            z-index: 20;
            gap: 0.6rem;
        }

        .table-header span {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .category-header {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: auto auto 1fr auto;
            position: sticky;
            top: 0;
            background-color: var(--bg-medium);
            padding: 0.35rem 0.6rem;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-dark);
            align-items: center;
            gap: 0.6rem;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }

        .category-header:hover {
            background-color: var(--bg-light);
        }

        .category-toggle {
            font-size: 0.8rem;
            transition: transform 0.2s ease;
            color: var(--text-muted);
        }

        .category-header.collapsed .category-toggle {
            transform: rotate(-90deg);
        }

        .category-files {
            display: contents;
        }

        .category-files.collapsed {
            display: none;
        }

        .category-header .category-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .category-header .category-name {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .category-header .column-header {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .file-row {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid var(--border-dark);
            cursor: pointer;
            transition: background-color 0.1s;
            gap: 0.6rem;
        }

        .file-row:hover {
            background-color: var(--bg-hover);
        }

        .file-row.selected {
            background-color: var(--bg-light);
            border-left: 2px solid var(--color-magic);
            padding-left: calc(0.6rem - 2px);
        }

        .file-row .category-indicator {
            width: 3px;
            height: 24px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .file-row .filename {
            font-size: 0.8rem;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .file-row .version-id {
            font-size: 0.7rem;
            color: var(--color-magic);
            font-family: var(--font-mono);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .file-row .version-id.pe-version {
            color: var(--color-unique);
        }

        .file-row .version-id.static {
            color: var(--text-muted);
            font-style: italic;
        }

        .file-row .variants {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: var(--font-mono);
            text-align: center;
            min-width: 20px;
        }

        .file-row .variants.many {
            color: var(--color-rare);
        }

        .file-row .hash-cell {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .file-row .hash-short {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: var(--font-mono);
            cursor: default;
        }

        .file-row .hash-copy-btn {
            background: none;
            border: 1px solid var(--border-dark);
            color: var(--text-muted);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.6rem;
            line-height: 1;
        }

        .file-row .hash-copy-btn:hover {
            border-color: var(--color-magic);
            color: var(--color-magic);
        }

        /* Panel 3: Cross Version Matrix */
        .panel-details {
            flex: 1;
            min-width: 300px;
            max-width: 100%;
            overflow: hidden;
        }

        .details-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .details-empty-icon {
            font-size: 2rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .details-empty-text {
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .file-stats {
            padding: 0.8rem;
            background: linear-gradient(180deg, var(--bg-light) 0%, var(--bg-medium) 100%);
            border-bottom: 1px solid var(--border-dark);
        }

        .file-stats-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.6rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .file-stats-title .category-tag {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-weight: 500;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .stat-item {
            background-color: var(--bg-dark);
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-dark);
        }

        .stat-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 0.85rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .stat-value.variants {
            color: var(--color-rare);
        }

        .stat-value.stable {
            color: var(--color-set);
        }

        .stat-value.unstable {
            color: var(--color-crafted);
        }

        .hash-display {
            padding: 0.6rem 0.8rem;
            background-color: var(--bg-darkest);
            border-bottom: 1px solid var(--border-dark);
        }

        .hash-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.2rem;
        }

        .hash-value {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-secondary);
            word-break: break-all;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .hash-text {
            flex: 1;
            cursor: pointer;
        }

        .hash-text:hover {
            color: var(--color-magic);
        }

        .copy-btn {
            background: none;
            border: 1px solid var(--border-dark);
            color: var(--text-muted);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.65rem;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            border-color: var(--color-magic);
            color: var(--color-magic);
        }

        .evolution-section {
            padding: 0.6rem 0.8rem;
            border-bottom: 1px solid var(--border-dark);
        }

        .evolution-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.6rem;
        }

        .evolution-timeline {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
            font-size: 0.75rem;
        }

        .timeline-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--color-magic);
            flex-shrink: 0;
            position: relative;
        }

        .timeline-dot.current {
            background-color: var(--color-set);
            box-shadow: 0 0 6px var(--color-set);
        }

        .timeline-dot::before {
            content: '';
            position: absolute;
            left: 50%;
            bottom: 100%;
            width: 1px;
            height: 8px;
            background-color: var(--border-light);
            transform: translateX(-50%);
        }

        .timeline-item:first-child .timeline-dot::before {
            display: none;
        }

        .timeline-versions {
            color: var(--text-primary);
            flex: 1;
        }

        .timeline-versions .range {
            color: var(--text-secondary);
            font-size: 0.65rem;
        }

        .timeline-hash {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .variants-section {
            padding: 0.6rem 0.8rem;
        }

        .variants-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }

        .variant-row {
            display: flex;
            align-items: center;
            padding: 0.4rem;
            background-color: var(--bg-darkest);
            border-radius: 4px;
            margin-bottom: 0.3rem;
            gap: 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .variant-row:hover {
            background-color: var(--bg-hover);
        }

        .variant-row.current {
            border: 1px solid var(--color-set);
            background-color: rgba(0, 255, 0, 0.05);
        }

        .variant-id {
            color: var(--color-magic);
            font-family: var(--font-mono);
            min-width: 100px;
        }

        .variant-versions {
            flex: 1;
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .variant-size {
            color: var(--text-muted);
            font-family: var(--font-mono);
            font-size: 0.7rem;
        }

        .variant-delta {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            min-width: 55px;
            text-align: right;
        }

        .variant-delta.size-increase {
            color: var(--color-crafted);
        }

        .variant-delta.size-decrease {
            color: var(--color-set);
        }

        /* Exports Table (for DLLs) */
        .exports-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        .exports-header {
            padding: 0.6rem 0.8rem;
            background: linear-gradient(180deg, var(--bg-light) 0%, var(--bg-medium) 100%);
            border-bottom: 1px solid var(--border-dark);
            flex-shrink: 0;
        }

        .exports-header-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.3rem;
        }

        .exports-header-info {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .exports-toolbar {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.4rem 0.6rem;
            padding: 0.4rem 0.8rem;
            background-color: var(--bg-medium);
            border-bottom: 1px solid var(--border-dark);
            flex-shrink: 0;
        }

        .exports-toolbar-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            width: 100%;
        }

        .exports-toolbar-group {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .exports-toolbar-separator {
            width: 1px;
            height: 16px;
            background-color: var(--border-dark);
            margin: 0 0.2rem;
        }

        /* Category legend in toolbar */
        .category-legend {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }

        .category-legend-item {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.6rem;
            color: var(--text-muted);
            cursor: help;
        }

        .category-legend-bar {
            width: 3px;
            height: 12px;
            border-radius: 1px;
        }

        .category-legend-bar.cat-game {
            background-color: #00FF00;
        }

        .category-legend-bar.cat-crt {
            background-color: #8B2020;
        }

        .category-legend-bar.cat-exception {
            background-color: #FF6600;
        }

        .category-legend-bar.cat-import {
            background-color: #6969FF;
        }

        .category-legend-bar.cat-other {
            background-color: #404040;
        }

        .exports-search {
            flex: 1;
            min-width: 120px;
            max-width: 180px;
            padding: 0.25rem 0.4rem;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.7rem;
            font-family: var(--font-mono);
        }

        .exports-search:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .exports-search::placeholder {
            color: var(--text-muted);
        }

        .exports-toggle {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.4rem;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: all 0.15s;
            white-space: nowrap;
        }

        .exports-toggle:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .exports-toggle.active {
            border-color: var(--color-set);
            color: var(--color-set);
            background-color: rgba(0, 255, 0, 0.1);
        }

        .exports-toggle-indicator {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            border: 1px solid currentColor;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.5rem;
        }

        .exports-toggle.active .exports-toggle-indicator::after {
            content: "✓";
        }

        .exports-stats {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-left: auto;
        }

        .exports-stats .named-count {
            color: var(--color-set);
        }

        /* Category filter dropdown */
        .category-filter {
            padding: 0.2rem 0.3rem;
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.65rem;
            cursor: pointer;
        }

        .category-filter:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        /* Category color bar for function rows */
        .fn-category-bar {
            width: 3px;
            height: 18px;
            border-radius: 1px;
            flex-shrink: 0;
            margin-right: 0.3rem;
            align-self: stretch;
        }

        .fn-category-bar.cat-game {
            background-color: #00FF00;
        }

        .fn-category-bar.cat-crt {
            background-color: #8B2020;
        }

        .fn-category-bar.cat-exception {
            background-color: #FF6600;
        }

        .fn-category-bar.cat-import {
            background-color: #6969FF;
        }

        .fn-category-bar.cat-other {
            background-color: #404040;
        }

        /* Function name cell layout - only for body cells, not header */
        .exports-table tbody .fn-name-cell {
            display: flex;
            align-items: center;
        }

        /* Ensure header cell stays in table layout for sticky to work */
        .exports-table thead th.fn-name-cell {
            display: table-cell;
        }

        /* Exact match with selected version - blue color */
        .exports-table .addr-cell.exact-match {
            color: #6969ff !important;
            font-weight: 600 !important;
        }

        /* BSim similarity-based color coding */
        .exports-table .addr-cell.similarity-identical {
            color: #0066ff !important;
            font-weight: 700 !important;
        }

        .exports-table .addr-cell.similarity-high {
            color: #0099cc !important;
            font-weight: 600 !important;
        }

        .exports-table .addr-cell.similarity-good {
            color: #00cc66 !important;
            font-weight: 600 !important;
        }

        .exports-table .addr-cell.similarity-medium {
            color: #99cc00 !important;
            font-weight: 500 !important;
        }

        .exports-table .addr-cell.similarity-low {
            color: #cc9900 !important;
            font-weight: 400 !important;
        }

        .exports-table .addr-cell.similarity-very-low {
            color: #cc6600 !important;
            font-weight: 400 !important;
        }

        /* Tier-colored address cells */
        .exports-table .addr-cell.tier-1-match {
            color: var(--accent-gold);
            font-weight: 600;
        }

        .exports-table .addr-cell.tier-2-match {
            color: var(--color-set);
        }

        .exports-table .addr-cell.tier-3-match {
            color: var(--color-magic);
        }

        .exports-table .addr-cell.tier-4-match {
            color: var(--color-crafted);
        }

        /* Duplicate function indicator */
        .fn-duplicate-indicator {
            color: var(--color-rare);
            font-size: 0.6rem;
            margin-left: 0.3rem;
            cursor: help;
        }

        /* Compiler boundary indicator */
        .addr-cell.compiler-boundary {
            border-left: 2px solid var(--accent-red);
        }

        /* Gap pattern indicators */
        .fn-name-cell.has-gaps {
            position: relative;
        }

        .fn-gap-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-left: 0.3rem;
            cursor: help;
        }

        .fn-gap-indicator.gap-post111 {
            background-color: var(--accent-red);
        }

        .fn-gap-indicator.gap-pre111 {
            background-color: var(--color-crafted);
        }

        .fn-gap-indicator.gap-sporadic {
            background-color: var(--color-rare);
        }

        .exports-table-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            min-height: 0;
        }

        .exports-table {
            border-collapse: separate;
            border-spacing: 0;
            width: auto;
        }

        .exports-table th,
        .exports-table td {
            padding: 0.3rem 0.5rem;
            border-bottom: 1px solid var(--border-dark);
            border-right: 1px solid var(--border-dark);
            font-size: 0.7rem;
            white-space: nowrap;
        }

        .exports-table thead th {
            background-color: var(--bg-medium);
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .exports-table thead th.selected-version {
            background-color: var(--accent-gold);
            color: var(--bg-darkest);
        }

        /* Sortable column headers */
        .exports-table thead th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.15s;
        }

        .exports-table thead th.sortable:hover {
            background-color: var(--bg-light);
        }

        .exports-table thead th.sortable.selected-version:hover {
            background-color: #d4c790;
        }

        .exports-table thead th .sort-indicator {
            display: inline-block;
            margin-left: 4px;
            opacity: 0.4;
            font-size: 0.6rem;
        }

        .exports-table thead th.sort-asc .sort-indicator,
        .exports-table thead th.sort-desc .sort-indicator {
            opacity: 1;
        }

        .exports-table thead th.sort-asc .sort-indicator::after {
            content: '▲';
        }

        .exports-table thead th.sort-desc .sort-indicator::after {
            content: '▼';
        }

        .exports-table thead th:not(.sort-asc):not(.sort-desc) .sort-indicator::after {
            content: '⇅';
        }

        .exports-table tbody tr:hover {
            background-color: var(--bg-hover);
        }

        .exports-table .fn-name-cell {
            position: sticky;
            left: 0;
            background-color: var(--bg-dark);
            z-index: 10;
            font-family: var(--font-mono);
            color: var(--text-primary);
            min-width: 150px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .exports-table thead th.fn-name-cell {
            z-index: 30;
            background-color: var(--bg-medium);
        }

        .exports-table tbody tr:hover .fn-name-cell {
            background-color: var(--bg-hover);
        }

        /* Compare panel active highlighting */
        .exports-table tbody tr.compare-active-row {
            background-color: rgba(0, 200, 83, 0.15) !important;
        }

        .exports-table tbody tr.compare-active-row .fn-name-cell {
            background-color: rgba(0, 200, 83, 0.15) !important;
        }

        .exports-table td.compare-active-cell {
            background-color: rgba(0, 200, 83, 0.3) !important;
            box-shadow: inset 0 0 0 2px var(--color-set);
        }

        .exports-table thead th.compare-active-column {
            background-color: rgba(0, 200, 83, 0.2) !important;
            box-shadow: inset 0 -2px 0 var(--color-set);
        }

        .exports-table .addr-cell {
            font-family: var(--font-mono);
            color: var(--color-magic);
            text-align: center;
        }

        .exports-table .addr-cell.changed {
            color: var(--color-crafted);
            font-weight: 600;
        }

        .exports-table .addr-cell.missing {
            color: var(--text-muted);
            font-style: italic;
        }

        .exports-table .fn-name-cell.named-func {
            color: var(--color-set);
            font-weight: 600;
        }

        /* Ghidra-style function name colors */
        .exports-table .fn-name-cell.ghidra-unnamed {
            color: #808080;
            /* Gray - FUN_* auto-generated */
        }

        .exports-table .fn-name-cell.ghidra-ordinal {
            color: #DAA520;
            /* Goldenrod - Ordinal_* thunks */
            font-weight: 600;
        }

        .exports-table .fn-name-cell.ghidra-named {
            color: #00CED1;
            /* Dark Cyan - User-defined names */
            font-weight: 600;
        }

        .exports-table .fn-name-cell.ghidra-import {
            color: #6495ED;
            /* Cornflower Blue - Imported functions */
        }

        .exports-table .fn-name-cell.ghidra-library {
            color: #87CEEB;
            /* Sky Blue - CRT/library functions */
        }

        .exports-table .fn-name-cell.ghidra-exception {
            color: #FFA07A;
            /* Light Salmon - Exception handling */
        }

        .exports-table .fn-name-cell.ghidra-thunk {
            color: #CD5C5C;
            /* Indian Red - Thunk/wrapper functions */
            font-weight: 600;
        }

        /* Match tier indicators */
        .tier-indicator {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 3px;
            text-align: center;
            font-size: 0.6rem;
            font-weight: 700;
            line-height: 18px;
            margin-right: 0.3rem;
            flex-shrink: 0;
        }

        .tier-1 {
            background-color: rgba(199, 179, 119, 0.3);
            color: var(--accent-gold);
            border: 1px solid var(--accent-gold);
        }

        .tier-2 {
            background-color: rgba(0, 255, 0, 0.2);
            color: var(--color-set);
            border: 1px solid var(--color-set);
        }

        .tier-3 {
            background-color: rgba(105, 105, 255, 0.2);
            color: var(--color-magic);
            border: 1px solid var(--color-magic);
        }

        .tier-4 {
            background-color: rgba(255, 102, 0, 0.2);
            color: var(--color-crafted);
            border: 1px solid var(--color-crafted);
        }

        /* Candidate match styles - yellow/orange for unconfirmed matches */
        .exports-table .addr-cell.candidate {
            color: var(--color-rare);
            font-style: italic;
            cursor: pointer;
            position: relative;
        }

        .exports-table .addr-cell.candidate:hover {
            background-color: rgba(255, 255, 0, 0.1);
        }

        .exports-table .addr-cell.candidate::before {
            content: "?";
            position: absolute;
            left: 2px;
            top: 2px;
            font-size: 0.5rem;
            color: var(--color-rare);
            opacity: 0.7;
        }

        .exports-table .addr-cell.candidate-high {
            color: var(--color-set);
        }

        .exports-table .addr-cell.candidate-low {
            color: var(--color-crafted);
        }

        .exports-table .addr-cell.confirmed {
            color: var(--color-set);
            font-weight: 600;
        }

        .exports-table .addr-cell.rejected {
            color: var(--accent-red-light);
            text-decoration: line-through;
            opacity: 0.5;
        }

        /* Dynamic candidate (computed on-the-fly, not pre-stored) */
        .exports-table .addr-cell.dynamic-candidate {
            font-style: italic;
            opacity: 0.8;
        }

        .exports-table .addr-cell.dynamic-candidate::before {
            content: '~';
        }

        /* Panel 4: Compare Functions */
        .panel-compare {
            width: 420px;
            flex-shrink: 0;
            border-left: 1px solid var(--accent-gold);
            display: none;
        }

        .panel-compare.visible {
            display: flex;
        }

        .panel-compare .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-compare .panel-header h2 {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .compare-close-btn {
            background: none;
            border: 1px solid var(--border-dark);
            color: var(--text-secondary);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }

        .compare-close-btn:hover {
            border-color: var(--accent-red-light);
            color: var(--accent-red-light);
        }

        /* Compare Header Info */
        .compare-header-info {
            padding: 0.6rem 0.8rem;
            background: linear-gradient(180deg, var(--bg-medium) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--border-dark);
        }

        .compare-func-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
            word-break: break-word;
        }

        .compare-func-name .known-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.3rem;
            background: var(--color-set);
            color: var(--bg-darkest);
            border-radius: 2px;
            margin-left: 0.4rem;
            font-weight: 500;
        }

        .compare-versions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .compare-version-info {
            flex: 1;
            min-width: 0;
        }

        .compare-version-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .compare-version-value {
            font-family: var(--font-mono);
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .compare-version-info.source .compare-version-value {
            color: var(--color-magic);
        }

        .compare-version-info.target .compare-version-value {
            color: var(--color-rare);
        }

        .compare-score {
            text-align: center;
            padding: 0.3rem 0.5rem;
            background: var(--bg-darkest);
            border-radius: 4px;
            border: 1px solid var(--border-dark);
        }

        .compare-score-value {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .compare-score-value.high {
            color: var(--color-set);
        }

        .compare-score-value.medium {
            color: var(--color-rare);
        }

        .compare-score-value.low {
            color: var(--color-crafted);
        }

        .compare-score-tier {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        /* Compare Content - Row Layout */
        .compare-section {
            border-bottom: 1px solid var(--border-dark);
        }

        .compare-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background: var(--bg-medium);
            cursor: pointer;
            user-select: none;
        }

        .compare-section-header:hover {
            background: var(--bg-light);
        }

        .compare-section-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .compare-section-summary {
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .compare-section-summary .match-count {
            color: var(--color-set);
        }

        .compare-section-summary .match-checkmark {
            color: var(--color-set);
            font-weight: bold;
        }

        .compare-section-content {
            background: var(--bg-dark);
        }

        .compare-section.collapsed .compare-section-content {
            display: none;
        }

        /* Column Headers */
        .compare-columns-header {
            display: grid;
            grid-template-columns: 1fr 100px 1fr 28px;
            gap: 0.3rem;
            padding: 0.25rem 0.6rem;
            background: var(--bg-darkest);
            border-bottom: 1px solid var(--border-dark);
        }

        .compare-col-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .compare-col-label.source {
            text-align: right;
            color: var(--color-magic);
        }

        .compare-col-label.metric {
            text-align: center;
        }

        .compare-col-label.target {
            text-align: left;
            color: var(--color-rare);
        }

        .compare-col-label.match {
            text-align: center;
        }

        /* Compare Row */
        .compare-row {
            display: grid;
            grid-template-columns: 1fr 100px 1fr 28px;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            border-bottom: 1px solid var(--border-dark);
            font-size: 0.75rem;
            align-items: center;
        }

        .compare-row:last-child {
            border-bottom: none;
        }

        .compare-row:hover {
            background: var(--bg-medium);
        }

        .compare-row .source {
            text-align: right;
            font-family: var(--font-mono);
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .compare-row .metric {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.65rem;
        }

        .compare-row .target {
            text-align: left;
            font-family: var(--font-mono);
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .compare-row .match-icon {
            text-align: center;
            font-size: 0.8rem;
        }

        .compare-row .match-icon.exact {
            color: var(--color-set);
        }

        .compare-row .match-icon.close {
            color: var(--color-rare);
        }

        .compare-row .match-icon.diff {
            color: var(--color-crafted);
        }

        .compare-row .match-icon.missing {
            color: var(--text-muted);
        }

        /* List Comparison (for callees, strings, etc.) */
        .compare-list {
            padding: 0.4rem 0.6rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .compare-list-item {
            font-size: 0.65rem;
            font-family: var(--font-mono);
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            background: var(--bg-darkest);
            border: 1px solid var(--border-dark);
            white-space: nowrap;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .compare-list-item.matched {
            border-color: var(--color-set);
            color: var(--color-set);
        }

        .compare-list-item.source-only {
            border-color: var(--color-magic);
            color: var(--color-magic);
            opacity: 0.7;
        }

        .compare-list-item.source-only::before {
            content: '⊖ ';
        }

        .compare-list-item.target-only {
            border-color: var(--color-rare);
            color: var(--color-rare);
            opacity: 0.7;
        }

        .compare-list-item.target-only::before {
            content: '⊕ ';
        }

        /* Paired list display (side-by-side comparison) */
        .compare-paired-list {
            padding: 0.3rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .compare-paired-header {
            display: grid;
            grid-template-columns: 1fr 24px 1fr;
            gap: 0.25rem;
            padding: 0.2rem 0.4rem;
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-dark);
            margin-bottom: 0.2rem;
        }

        .compare-paired-row {
            display: grid;
            grid-template-columns: 1fr 24px 1fr;
            gap: 0.25rem;
            padding: 0.15rem 0.4rem;
            font-size: 0.65rem;
            font-family: var(--font-mono);
            border-radius: 2px;
        }

        .compare-paired-row:hover {
            background: var(--bg-light);
        }

        .paired-col-source,
        .paired-col-target {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Click-to-copy styling */
        .copyable {
            cursor: pointer;
            transition: background-color 0.15s ease;
            border-radius: 2px;
            padding: 1px 3px;
            margin: -1px -3px;
        }

        .copyable:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .copyable.copied {
            background: rgba(0, 200, 83, 0.3) !important;
        }

        .copyable::after {
            content: '';
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .copyable:hover::after {
            content: ' [click to copy]';
            opacity: 0.5;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .copyable.copied::after {
            content: ' copied!';
            opacity: 1;
            color: var(--color-set);
        }

        .paired-col-match {
            text-align: center;
            font-size: 0.7rem;
        }

        /* Match type styling */
        .compare-paired-row.match-exact {
            background: rgba(0, 200, 83, 0.08);
        }

        .compare-paired-row.match-exact .paired-col-match {
            color: var(--color-set);
        }

        .compare-paired-row.match-exact .paired-col-source,
        .compare-paired-row.match-exact .paired-col-target {
            color: var(--color-set);
        }

        .compare-paired-row.match-normalized {
            background: rgba(255, 199, 0, 0.08);
        }

        .compare-paired-row.match-normalized .paired-col-match {
            color: var(--color-rare);
        }

        .compare-paired-row.match-normalized .paired-col-source,
        .compare-paired-row.match-normalized .paired-col-target {
            color: var(--color-rare);
        }

        .compare-paired-row.match-source-only {
            opacity: 0.75;
        }

        .compare-paired-row.match-source-only .paired-col-match {
            color: var(--color-magic);
        }

        .compare-paired-row.match-source-only .paired-col-source {
            color: var(--color-magic);
        }

        .compare-paired-row.match-source-only .paired-col-target {
            color: var(--text-muted);
        }

        .compare-paired-row.match-target-only {
            opacity: 0.75;
        }

        .compare-paired-row.match-target-only .paired-col-match {
            color: var(--color-crafted);
        }

        .compare-paired-row.match-target-only .paired-col-source {
            color: var(--text-muted);
        }

        .compare-paired-row.match-target-only .paired-col-target {
            color: var(--color-crafted);
        }

        .compare-paired-empty {
            padding: 0.5rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .compare-section-summary .match-count-normalized {
            color: var(--color-rare);
            font-weight: 600;
        }

        /* Signature Row (full width) */
        .compare-signature-row {
            padding: 0.4rem 0.6rem;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-secondary);
            word-break: break-word;
            border-bottom: 1px solid var(--border-dark);
        }

        .compare-signature-row .sig-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.2rem;
        }

        /* Hash Row */
        .compare-hash-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid var(--border-dark);
        }

        .compare-hash-value {
            font-family: var(--font-mono);
            font-size: 0.6rem;
            color: var(--text-secondary);
            word-break: break-all;
            padding: 0.3rem;
            background: var(--bg-darkest);
            border-radius: 3px;
        }

        .compare-hash-value.match {
            border: 1px solid var(--color-set);
            color: var(--color-set);
        }

        .compare-hash-value .hash-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.15rem;
        }

        /* Compare Actions */
        .compare-actions {
            padding: 0.6rem;
            background: var(--bg-medium);
            border-top: 1px solid var(--border-dark);
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .compare-actions.hidden {
            display: none;
        }

        .compare-btn {
            flex: 1;
            padding: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .compare-btn.confirm {
            background: rgba(66, 184, 131, 0.1);
            border-color: var(--color-set);
            color: var(--color-set);
        }

        .compare-btn.confirm:hover {
            background: rgba(66, 184, 131, 0.2);
        }

        .compare-btn.reject {
            background: rgba(231, 76, 60, 0.1);
            border-color: var(--accent-red-light);
            color: var(--accent-red-light);
        }

        .compare-btn.reject:hover {
            background: rgba(231, 76, 60, 0.2);
        }

        /* Narrow screen support */
        @media (max-width: 1200px) {
            .panel-compare {
                width: 350px;
            }

            /* Prevent toolbar wrapping on medium screens */
            .files-toolbar {
                flex-wrap: nowrap;
                overflow-x: auto;
            }

            .category-filters {
                flex-wrap: nowrap;
                overflow-x: auto;
                min-width: 0;
            }
        }

        @media (max-width: 900px) {
            .panel-compare {
                width: 300px;
                min-width: 280px;
            }

            .compare-columns-header,
            .compare-row {
                grid-template-columns: 1fr 80px 1fr 24px;
            }

            /* Force no wrapping on smaller screens */
            .files-toolbar {
                flex-wrap: nowrap;
                padding: 0.3rem 0.5rem;
                gap: 0.3rem;
            }

            .category-filters {
                flex-wrap: nowrap;
                gap: 0.15rem;
                min-width: 0;
                flex-shrink: 1;
            }

            .category-btn {
                padding: 0.15rem 0.3rem;
                font-size: 0.55rem;
                white-space: nowrap;
                flex-shrink: 0;
                min-width: auto;
            }

            /* Hide full text on very small screens to save space */
            .category-btn .full-text {
                display: none;
            }

            .category-btn .short-text {
                display: inline;
            }

            .group-btn {
                padding: 0.15rem 0.3rem;
                font-size: 0.55rem;
                flex-shrink: 0;
            }
        }

        /* Match Score Breakdown Section */
        .score-breakdown {
            padding: 0.4rem 0.6rem;
        }

        .score-breakdown-tier {
            margin-bottom: 0.5rem;
            padding: 0.4rem;
            background: var(--bg-darkest);
            border-radius: 4px;
            border-left: 3px solid var(--border-dark);
        }

        .score-breakdown-tier.tier-matched {
            border-left-color: var(--color-set);
        }

        .score-breakdown-tier.tier-partial {
            border-left-color: var(--color-rare);
        }

        .score-breakdown-tier .tier-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
            gap: 0.5rem;
        }

        .score-breakdown-tier .tier-icon {
            font-size: 0.8rem;
        }

        .score-breakdown-tier .tier-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-secondary);
            flex: 1;
        }

        .score-breakdown-tier .tier-status {
            font-size: 0.6rem;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            background: rgba(255, 102, 0, 0.15);
            color: var(--color-crafted);
        }

        .score-breakdown-tier.tier-matched .tier-status {
            background: rgba(0, 200, 83, 0.15);
            color: var(--color-set);
        }

        .score-breakdown-tier .tier-reason {
            font-size: 0.6rem;
            color: var(--color-set);
            padding-left: 1.3rem;
        }

        .score-breakdown-tier.tier-warning {
            border-left-color: var(--color-crafted);
        }

        /* Feature table in breakdown */
        .score-feature-table {
            width: 100%;
            font-size: 0.6rem;
            border-collapse: collapse;
        }

        .score-feature-table th {
            text-align: left;
            color: var(--text-muted);
            font-weight: 500;
            padding: 0.2rem 0.3rem;
            border-bottom: 1px solid var(--border-dark);
        }

        .score-feature-table td {
            padding: 0.2rem 0.3rem;
            color: var(--text-secondary);
        }

        .score-feature-table tr:hover {
            background: var(--bg-hover);
        }

        .score-feature-table .feat-name {
            color: var(--color-magic);
            font-weight: 500;
        }

        .score-feature-table .feat-vals {
            font-family: var(--font-mono);
            color: var(--text-primary);
        }

        .score-feature-table .feat-sim {
            text-align: right;
        }

        .score-feature-table .feat-contrib {
            text-align: right;
            width: 80px;
        }

        /* Contribution bar */
        .contrib-bar-container {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .contrib-bar {
            flex: 1;
            height: 6px;
            background: var(--bg-medium);
            border-radius: 3px;
            overflow: hidden;
        }

        .contrib-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.2s;
        }

        .contrib-bar-fill.high {
            background: var(--color-set);
        }

        .contrib-bar-fill.medium {
            background: var(--color-rare);
        }

        .contrib-bar-fill.low {
            background: var(--color-crafted);
        }

        .contrib-value {
            font-size: 0.55rem;
            color: var(--text-muted);
            min-width: 20px;
            text-align: right;
        }

        /* Value bonuses */
        .score-value-bonuses {
            margin-top: 0.3rem;
            padding-top: 0.3rem;
            border-top: 1px dashed var(--border-dark);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .score-value-bonuses .bonuses-label {
            font-size: 0.55rem;
            color: var(--text-muted);
        }

        .score-value-bonuses .bonus-tag {
            font-size: 0.55rem;
            padding: 0.1rem 0.4rem;
            background: rgba(0, 200, 83, 0.15);
            color: var(--color-set);
            border-radius: 3px;
            cursor: help;
        }

        .score-bonus-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.15rem 0;
            font-size: 0.6rem;
        }

        .score-bonus-item .bonus-label {
            color: var(--text-secondary);
        }

        .score-bonus-item .bonus-value {
            color: var(--color-set);
            font-weight: 600;
        }

        /* Score totals */
        .score-totals {
            margin-top: 0.4rem;
            padding: 0.4rem;
            background: var(--bg-medium);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-totals-row {
            display: flex;
            gap: 1rem;
            font-size: 0.65rem;
        }

        .score-totals-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .score-totals-item .label {
            color: var(--text-muted);
        }

        .score-totals-item .value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .score-totals-item .value.bonus {
            color: var(--color-set);
        }

        .score-final {
            font-size: 1rem;
            font-weight: 700;
        }

        .score-final.high {
            color: var(--color-set);
        }

        .score-final.medium {
            color: var(--color-rare);
        }

        .score-final.low {
            color: var(--color-crafted);
        }

        /* Validation warnings */
        .score-warnings {
            margin-top: 0.3rem;
        }

        .score-warnings .warning-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0.3rem;
            font-size: 0.6rem;
            color: var(--color-crafted);
            background: rgba(255, 102, 0, 0.1);
            border-radius: 3px;
            margin-bottom: 0.2rem;
        }

        /* Alternate Matches */
        .alternate-matches {
            padding: 0.4rem 0.6rem;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--border-dark);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .alternate-matches .alternate-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .alternate-matches .alternate-buttons {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .alternate-match-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.3rem 0.5rem;
            background: var(--bg-darkest);
            border: 1px solid var(--border-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            min-width: 70px;
        }

        .alternate-match-btn:hover {
            border-color: var(--accent-gold);
            background: var(--bg-hover);
        }

        .alternate-match-btn.selected {
            border-color: var(--color-magic);
            background: rgba(105, 105, 255, 0.1);
        }

        .alternate-match-btn .alt-rank {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .alternate-match-btn .alt-score {
            font-size: 0.85rem;
            font-weight: 700;
        }

        .alternate-match-btn .alt-score.high {
            color: var(--color-set);
        }

        .alternate-match-btn .alt-score.medium {
            color: var(--color-rare);
        }

        .alternate-match-btn .alt-score.low {
            color: var(--color-crafted);
        }

        .alternate-match-btn .alt-addr {
            font-size: 0.55rem;
            font-family: var(--font-mono);
            color: var(--text-secondary);
        }

        .alternate-match-btn .alt-name {
            font-size: 0.5rem;
            color: var(--text-muted);
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* NOTE: Old Comparison Modal CSS has been removed.
           The new Panel 4 (Compare Functions) uses .panel-compare and .compare-* classes defined above.

           Removed CSS classes: .comparison-modal, .comparison-dialog, .comparison-header,
           .comparison-title, .comparison-close, .comparison-content, .comparison-side,
           .comparison-side-header, .comparison-section, .comparison-section-title,
           .comparison-section-content, .comparison-list, .comparison-metrics,
           .comparison-metric, .metric-label, .metric-value, .comparison-callees,
           .callee-list, .callee-tag, .comparison-strings, .string-list, .string-ref,
           .comparison-hash, .hash-value, .comparison-similarity, .similarity-score,
           .similarity-breakdown, .similarity-item, .similarity-item-label, .similarity-bar,
           .comparison-confidence, .confidence-bar, .confidence-fill, .confidence-value,
           .comparison-actions, .comparison-btn, etc.
        */

        .tier-legend {
            display: flex;
            gap: 0.8rem;
            font-size: 0.65rem;
            color: var(--text-muted);
            padding: 0.3rem 0;
        }

        .tier-legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .exports-table .fn-name-cell {
            display: flex;
            align-items: center;
        }

        .fn-name-text {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .fn-signature {
            display: block;
            font-size: 0.75em;
            color: var(--text-dim);
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 280px;
            margin-top: 1px;
        }

        .fn-name-wrapper {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Text file view */
        .text-view-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-darkest);
        }

        .text-view-header {
            padding: 0.8rem;
            background: linear-gradient(180deg, var(--bg-light) 0%, var(--bg-medium) 100%);
            border-bottom: 1px solid var(--border-dark);
            flex-shrink: 0;
        }

        .text-view-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .text-view-filename {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .text-view-badge {
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .text-view-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .text-view-separator {
            color: var(--border-light);
        }

        .text-view-content {
            flex: 1;
            overflow: auto;
            padding: 0.8rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }

        .text-view-content::-webkit-scrollbar {
            width: 8px;
        }

        .text-view-content::-webkit-scrollbar-track {
            background: var(--bg-darkest);
        }

        .text-view-content::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        .text-view-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* HTML file view */
        .html-view-container {
            height: 100%;
            overflow: auto;
            background-color: #fff;
        }

        .html-view-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* MPQ placeholder */
        .mpq-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .mpq-placeholder-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .mpq-placeholder-text {
            font-size: 0.85rem;
            line-height: 1.5;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            background-color: var(--color-set);
            color: var(--bg-darkest);
            padding: 0.6rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Scrollbar styling */
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: var(--bg-darkest);
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        .panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Exports table scrollbar */
        .exports-table-wrapper::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .exports-table-wrapper::-webkit-scrollbar-track {
            background: var(--bg-darkest);
        }

        .exports-table-wrapper::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        .exports-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .exports-table-wrapper::-webkit-scrollbar-corner {
            background: var(--bg-darkest);
        }

        /* Footer */
        .footer {
            padding: 0.4rem 1rem;
            background-color: var(--bg-dark);
            border-top: 1px solid var(--border-dark);
            font-size: 0.7rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .footer-stat {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .footer-stat .value {
            color: var(--accent-gold);
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>BSim Analysis Portal</h1>
        <div class="header-search">
            <input type="text" id="hashSearch" placeholder="Search by hash..."
                onkeydown="if(event.key==='Enter') searchByHash()">
        </div>
    </div>

    <div class="main-container">
        <div class="panels-wrapper">
            <!-- Panel 1: Version Navigator -->
            <div class="panel panel-versions">
                <div class="panel-header">
                    <h2>Versions</h2>
                </div>
                <div class="panel-content">
                    <div class="version-list" id="versionList"></div>
                </div>
            </div>

            <!-- Panel 2: Files -->
            <div class="panel panel-files">
                <div class="panel-header panel-header-files">
                    <h2 id="filesTitle">Binaries</h2>
                    <input type="text" class="files-filter" id="filesFilter" placeholder="Filter..." oninput="filterFiles()" style="display: none;">
                </div>
                <div class="files-toolbar" id="filesToolbar" style="display: none; position: relative;">
                    <div class="category-filters" id="categoryFilters"></div>
                    <button class="group-btn" id="groupBtn" onclick="toggleGrouping()">
                        <span class="full-text">Group</span>
                        <span class="short-text">▤</span>
                    </button>
                </div>
                <div class="panel-content">
                    <div class="files-table" id="filesTable">
                        <div class="details-empty">
                            <div class="details-empty-icon">📂</div>
                            <div class="details-empty-text">Select a version</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Panel 3: Cross Version Matrix -->
            <div class="panel panel-details">
                <div class="panel-header">
                    <h2>Cross Version Matrix</h2>
                </div>
                <div class="panel-content" id="detailsContent">
                    <div class="details-empty">
                        <div class="details-empty-icon">🔍</div>
                        <div class="details-empty-text">
                            Select a file to view its evolution across versions<br><br>
                            Or search for a hash above to identify a file
                        </div>
                    </div>
                </div>
            </div>

            <!-- Panel 4: Compare Functions -->
            <div class="panel panel-compare" id="comparePanel">
                <div class="panel-header">
                    <h2 id="comparePanelTitle">Compare Functions</h2>
                    <button class="compare-close-btn" onclick="closeComparePanel()" title="Close comparison panel">✕</button>
                </div>
                <div class="compare-header-info" id="compareHeaderInfo">
                    <!-- Populated by showComparePanel() -->
                </div>
                <div class="panel-content" id="compareContent">
                    <div class="details-empty">
                        <div class="details-empty-icon">⚖️</div>
                        <div class="details-empty-text">
                            Click a function cell to compare<br>
                            source and target versions
                        </div>
                    </div>
                </div>
                <div class="compare-actions hidden" id="compareActions">
                    <button class="compare-btn confirm" id="compareBtnConfirm" onclick="confirmMatch()">✓ Confirm</button>
                    <button class="compare-btn reject" id="compareBtnReject" onclick="rejectMatch()">✗ Reject</button>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="footer-stat">
            <span class="value" id="statVersions">0</span> versions
        </div>
        <div class="footer-stat">
            <span class="value" id="statFiles">0</span> unique files
        </div>
        <div class="footer-stat">
            <span class="value" id="statHashes">0</span> file variants
        </div>
    </div>

    <div class="toast" id="toast">Copied to clipboard</div>

    <!-- API Data Loading -->
    <script>
        // API Configuration - Environment-based endpoint selection
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8081/api'  // Local development
            : 'https://api.xebyte.com/api'; // Production deployment

        // Global data variables (previously loaded from static files)
        let FILE_CATEGORIES = {};
        let VERSIONS_DATA = [];
        let FILE_HISTORY_DATA = {};
        let DIFFS_DATA = {};
        let EXPORTS_DATA = {};
        let TEXT_CONTENT_DATA = {};
        let FUNCTION_INDEX_V2 = {};

        // Hardcoded constants (previously embedded in static files)
        const COMPILER_BOUNDARY_VERSIONS = [
            'LoD/1.11',      // CRT/compiler changed significantly at 1.11
            'Classic/1.11'
        ];

        const PRE_111_VERSIONS = [
            'LoD/1.07', 'LoD/1.08', 'LoD/1.09', 'LoD/1.09b', 'LoD/1.09d', 'LoD/1.10',
            'Classic/1.00', 'Classic/1.01', 'Classic/1.02', 'Classic/1.03',
            'Classic/1.04b', 'Classic/1.04c', 'Classic/1.05', 'Classic/1.05b',
            'Classic/1.06', 'Classic/1.06b', 'Classic/1.08', 'Classic/1.09',
            'Classic/1.09b', 'Classic/1.09d', 'Classic/1.10'
        ];

        const CATEGORIES = {
            'Game Logic': { color: '#00FF00', short: 'GL' },
            'Graphics': { color: '#6969FF', short: 'GR' },
            'Audio': { color: '#A59263', short: 'AU' },
            'Network': { color: '#FF6600', short: 'NW' },
            'Launcher': { color: '#FFFF00', short: 'LA' },
            'MPQ': { color: '#C7B377', short: 'MPQ' },
            'Utility': { color: '#808080', short: 'UT' },
            'Other': { color: '#FFFFFF', short: 'OT' }
        };

        // API loading functions
        async function loadAPIData() {
            try {
                console.log('Starting API data load...');
                showLoadingToast('Loading BSim data from API...');

                // Load core data in parallel
                console.log('Fetching data from API endpoints...');
                const [categoriesRes, versionsRes, historyRes, diffsRes, exportsRes, textRes, functionsIndexRes] = await Promise.all([
                    fetch(`${API_BASE_URL}/categories`).catch(() => ({ ok: false, error: 'categories' })),
                    fetch(`${API_BASE_URL}/versions`).catch(() => ({ ok: false, error: 'versions' })),
                    fetch(`${API_BASE_URL}/file-history`).catch(() => ({ ok: false, error: 'file-history' })),
                    fetch(`${API_BASE_URL}/diffs`).catch(() => ({ ok: false, error: 'diffs' })),
                    fetch(`${API_BASE_URL}/exports`).catch(() => ({ ok: false, error: 'exports' })),
                    fetch(`${API_BASE_URL}/text-content`).catch(() => ({ ok: false, error: 'text-content' })),
                    fetch(`${API_BASE_URL}/functions/index`).catch(() => ({ ok: false, error: 'functions/index' }))
                ]);

                // Process responses
                console.log('Processing API responses...');
                console.log('Versions response status:', versionsRes.ok);
                if (categoriesRes.ok) FILE_CATEGORIES = await categoriesRes.json();
                if (versionsRes.ok) {
                    const rawVersions = await versionsRes.json();
                    console.log('Raw versions data:', rawVersions.length, 'items');
                    // Transform game_versions table response for compatibility
                    VERSIONS_DATA = rawVersions.map(v => ({
                        folder_name: `${v.versionFamily}/${v.versionString}`,
                        game_type: v.versionFamily,
                        version: v.versionString,
                        file_count: 0, // Will be populated from binaries API
                        change_count: 0, // Will be populated from binaries API
                        is_lod: v.versionFamily === 'LoD',
                        raw_pe_version: v.versionString,
                        total_size_readable: 'Unknown',
                        nocd_status: 'unknown',
                        description: v.description,
                        created_at: v.createdAt,
                        id: v.id
                    }));
                }
                if (historyRes.ok) FILE_HISTORY_DATA = await historyRes.json();
                if (diffsRes.ok) DIFFS_DATA = await diffsRes.json();
                if (exportsRes.ok) EXPORTS_DATA = await exportsRes.json();
                if (textRes.ok) TEXT_CONTENT_DATA = await textRes.json();
                if (functionsIndexRes.ok) FUNCTION_INDEX_V2 = await functionsIndexRes.json();

                console.log('API Data loaded successfully!');
                console.log('- Categories:', Object.keys(FILE_CATEGORIES).length);
                console.log('- Versions:', VERSIONS_DATA.length);
                console.log('- Functions:', Object.keys(FUNCTION_INDEX_V2.files || {}).length);

                hideLoadingToast();
                return true;

            } catch (error) {
                console.error('Failed to load API data:', error);
                hideLoadingToast();
                showErrorToast('Failed to connect to BSim API. Please check the API connection.');

                // No fallback data - return false to indicate failure
                console.log('No fallback data - API connection required');
                return false;
            }
        }

        // Modified loadFunctionData to use BSim-enhanced API
        async function loadFunctionData(filename, forceGroup = false) {
            if (!filename) return null;

            // Get the currently selected version for BSim baseline
            const currentSelectedVersion = selectedVersion ? selectedVersion.split('/')[1] || selectedVersion : '1.00';

            // Check if already loaded for this version
            const dataVarName = `FUNCTIONS_${filename.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase()}_${currentSelectedVersion.replace(/[^a-zA-Z0-9]/g, '_')}`;
            if (window[dataVarName] && !forceGroup) {
                console.log(`Function data for ${filename} (version ${currentSelectedVersion}) already loaded`);
                return window[dataVarName];
            }

            try {
                showLoadingToast(`Loading BSim analysis for ${filename} (baseline: ${currentSelectedVersion})...`);

                // Try the new BSim-enhanced endpoint first
                let response;
                let apiData;
                let usedBSim = false;

                try {
                    response = await fetch(`${API_BASE_URL}/functions/cross-version/${currentSelectedVersion}/${filename}?threshold=0.6`);
                    if (response.ok) {
                        apiData = await response.json();
                        usedBSim = true;
                        console.log(`BSim analysis loaded for ${filename} with baseline ${currentSelectedVersion}`);
                    }
                } catch (bsimError) {
                    console.log(`BSim endpoint failed, falling back to original endpoint:`, bsimError.message);
                }

                // Fallback to original endpoint if BSim fails
                if (!usedBSim) {
                    response = await fetch(`${API_BASE_URL}/functions/cross-version/${filename}`);
                    if (!response.ok) {
                        throw new Error(`Failed to load function data for ${filename}`);
                    }
                    apiData = await response.json();
                    console.log(`Fallback to name-based matching for ${filename}`);
                }

                if (apiData.error) {
                    throw new Error(apiData.error);
                }

                // Transform API response to match expected format for renderFunctionsTable
                const functionData = {
                    versions: apiData.versions || [],
                    functions: {},
                    filename: filename,
                    versionMd5s: apiData.versionMd5s || {},
                    isExe: apiData.isExe || false,
                    usedBSim: usedBSim,
                    baselineVersion: apiData.baselineVersion || currentSelectedVersion
                };

                // Transform functions: { funcName: { addresses: { version: addr }, similarities: { version: score } } }
                if (apiData.functions) {
                    for (const [funcName, funcData] of Object.entries(apiData.functions)) {
                        functionData.functions[funcName] = {
                            name: funcData.name || funcName,
                            category: funcData.category || 'Game',
                            addresses: funcData.addresses || {},
                            similarities: funcData.similarities || {}  // Add similarity scores
                        };
                    }
                }

                window[dataVarName] = functionData;

                console.log(`Loaded function data for ${filename}:`, Object.keys(functionData.functions).length, 'functions,', functionData.versions.length, 'versions');
                hideLoadingToast();

                return functionData;

            } catch (error) {
                console.error(`Error loading function data for ${filename}:`, error);
                hideLoadingToast();
                showErrorToast(`Failed to load functions for ${filename}`);
                return null;
            }
        }

        // Toast notification functions
        function showLoadingToast(message) {
            const toast = document.getElementById('toast');
            if (toast) {
                toast.textContent = message;
                toast.style.backgroundColor = 'var(--color-magic)';
                toast.classList.add('show');
            }
        }

        function hideLoadingToast() {
            const toast = document.getElementById('toast');
            if (toast) {
                toast.classList.remove('show');
            }
        }

        function showErrorToast(message) {
            const toast = document.getElementById('toast');
            if (toast) {
                toast.textContent = message;
                toast.style.backgroundColor = 'var(--accent-red)';
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 5000);
            }
        }

        // Compatibility: Create FUNCTION_INDEX from V2 data
        var FUNCTION_INDEX = {
            generated: FUNCTION_INDEX_V2 ? FUNCTION_INDEX_V2.generated : null,
            split_format: false,
            files: {}
        };
        if (typeof FUNCTION_INDEX_V2 !== 'undefined' && FUNCTION_INDEX_V2.files) {
            for (const [name, info] of Object.entries(FUNCTION_INDEX_V2.files)) {
                FUNCTION_INDEX.files[name] = {
                    split: false,
                    count: info.count,
                    named: info.named,
                    versions: info.versions
                };
            }
        }
        console.log('FUNCTION_INDEX (compat) files:', Object.keys(FUNCTION_INDEX.files || {}));

        // State
        let selectedVersion = null;
        let selectedFile = null;
        let isGrouped = true;
        let collapsedCategories = {}; // Track which categories are collapsed

        // Version filters: Pre-Refactor (1.00-1.03), Post-Refactor (1.04+), LoD (all)
        const versionFilters = {
            preRefactor: true,    // Classic 1.00-1.03 (old codebase)
            postRefactor: true,   // Classic 1.04+ (refactored codebase)
            lod: true             // All LoD versions
        };

        // Version group definitions
        const VERSION_GROUPS = {
            preRefactor: ['Classic/1.00', 'Classic/1.01', 'Classic/1.02', 'Classic/1.03'],
            postRefactor: ['Classic/1.04b', 'Classic/1.04c', 'Classic/1.05', 'Classic/1.05b', 'Classic/1.06', 'Classic/1.06b', 'Classic/1.08', 'Classic/1.09', 'Classic/1.09b', 'Classic/1.09d', 'Classic/1.10', 'Classic/1.11', 'Classic/1.11b', 'Classic/1.12a', 'Classic/1.13c', 'Classic/1.13d', 'Classic/1.14a', 'Classic/1.14b', 'Classic/1.14c', 'Classic/1.14d'],
            lod: ['LoD/1.07', 'LoD/1.08', 'LoD/1.09', 'LoD/1.09b', 'LoD/1.09d', 'LoD/1.10', 'LoD/1.11', 'LoD/1.11b', 'LoD/1.12a', 'LoD/1.13c', 'LoD/1.13d', 'LoD/1.14a', 'LoD/1.14b', 'LoD/1.14c', 'LoD/1.14d']
        };

        // Legacy compatibility
        let showClassic = true;
        let showLoD = true;

        // Function table filter state
        let funcSearchFilter = '';
        let showOnlyNamed = false;
        let showRVA = false;  // false = full address (default), true = RVA
        let showGapsOnly = false;  // show only functions with coverage gaps
        let copyOnClick = false;  // copy address to clipboard instead of opening compare modal
        let showSignatures = false;  // show function signatures under names
        let currentFuncData = null;
        let currentFuncBaseName = null;
        let categoryFilter = 'all';  // 'all', 'game_logic', 'crt_runtime', 'import_thunk', 'exception', 'other'


        // Detect function category based on name patterns
        function getFunctionCategory(name) {
            if (!name) return 'other';

            // CRT/Runtime library functions
            if (name.startsWith('___') || name.startsWith('__crt') || name.startsWith('__sbh') ||
                name.startsWith('__seh') || name.startsWith('_amsg') || name.startsWith('_except') ||
                name.match(/^_[a-z]/) || name.startsWith('__ansi') || name.startsWith('__convert') ||
                name.startsWith('__initm') || name.startsWith('__heap') || name.startsWith('__free') ||
                name.startsWith('__mt') || name.startsWith('__ld') || name.startsWith('__mul')) {
                return 'crt';
            }

            // Exception handling functions
            if (name.includes('Exception') || name.includes('FrameHandler') ||
                name.includes('Unwind') || name.includes('CxxThrow') ||
                name.includes('__CxxFrameHandler') || name.includes('SEH')) {
                return 'exception';
            }

            // Import thunks (usually ordinal references)
            if (name.startsWith('Ordinal_') || name.match(/^_imp__/) ||
                name.match(/^thunk_/) || name.match(/^j_/)) {
                return 'import';
            }

            // Game logic functions (have descriptive names)
            if (name.match(/^[A-Z][a-z]/) && name.length > 5 &&
                !name.startsWith('FUN_') && !name.startsWith('sub_')) {
                return 'game';
            }

            return 'other';
        }

        // Get category display info
        function getCategoryInfo(category) {
            const info = {
                game: { label: 'Game', barClass: 'cat-game', title: 'Game Logic Function' },
                crt: { label: 'CRT', barClass: 'cat-crt', title: 'C Runtime Library Function' },
                exception: { label: 'EH', barClass: 'cat-exception', title: 'Exception Handling Function' },
                import: { label: 'IMP', barClass: 'cat-import', title: 'Import/Thunk Function' },
                other: { label: '', barClass: 'cat-other', title: 'Uncategorized Function' }
            };
            return info[category] || info.other;
        }

        // Analyze function gap patterns
        function analyzeGapPattern(func, versionGroups) {
            // Extract all version strings from version groups
            const versions = [];
            for (const group of versionGroups) {
                if (group.versions) {
                    versions.push(...group.versions);
                } else if (typeof group === 'string') {
                    versions.push(group);
                }
            }

            if (versions.length === 0) return null;

            // Check how many versions have addresses
            let hasAddress = 0;
            let noAddress = 0;

            for (const v of versions) {
                if (func.addresses && func.addresses[v]) {
                    hasAddress++;
                } else {
                    noAddress++;
                }
            }

            // If function only exists in some versions (gaps exist)
            if (hasAddress > 0 && noAddress > 0) {
                const coverage = hasAddress / versions.length;

                // Significant gaps (less than 70% coverage or missing in multiple versions)
                if (coverage < 0.7 || noAddress >= 2) {
                    return { type: 'sporadic', title: `Gaps in version coverage (${hasAddress}/${versions.length} versions)` };
                }
            }

            // Check for pre/post 1.11 boundary patterns
            const pre111Addresses = [];
            const post111Addresses = [];

            for (const v of versions) {
                const hasAddr = func.addresses && func.addresses[v];
                if (PRE_111_VERSIONS.includes(v)) {
                    pre111Addresses.push(hasAddr ? v : null);
                } else {
                    post111Addresses.push(hasAddr ? v : null);
                }
            }

            const pre111Count = pre111Addresses.filter(Boolean).length;
            const post111Count = post111Addresses.filter(Boolean).length;

            // Only post-1.11 (likely CRT/compiler-specific)
            if (pre111Count === 0 && post111Count > 0 && pre111Addresses.length > 0) {
                return { type: 'post111', title: 'Only exists in 1.11+ (likely compiler-specific)' };
            }

            // Only pre-1.11 (disappeared after compiler change)
            if (pre111Count > 0 && post111Count === 0 && post111Addresses.length > 0) {
                return { type: 'pre111', title: 'Only exists in pre-1.11 (removed/replaced after compiler change)' };
            }

            return null;  // No significant gap pattern
        }

        // Detect duplicate function names
        function findDuplicateFunctions(funcData) {
            const nameCount = {};
            const duplicates = new Set();

            for (const [key, func] of Object.entries(funcData.functions)) {
                const name = func.name || key;
                if (!nameCount[name]) {
                    nameCount[name] = [];
                }
                nameCount[name].push(key);
            }

            for (const [name, keys] of Object.entries(nameCount)) {
                if (keys.length > 1) {
                    keys.forEach(k => duplicates.add(k));
                }
            }

            return duplicates;
        }

        // Table sort state
        let tableSortColumn = 'function';  // 'function' or version group index (0, 1, 2, ...)
        let tableSortDirection = 'asc';    // 'asc' or 'desc'
        let currentVersionGroups = [];     // Store version groups for sorting

        // Rarity index for identity matching
        let rarityIndex = null;  // { callees: Map, strings: Map, constants: Map }

        // Helper: Extract string value from "address|name|value" format
        function extractStringValue(s) {
            if (typeof s === 'string' && s.includes('|')) {
                const parts = s.split('|');
                if (parts.length >= 3) return parts[2];  // address|name|value
                if (parts.length === 2) return parts[1];  // address|value or address|name
            }
            return s;
        }

        // Helper: Extract constant value from "address||value" format
        function extractConstantValue(c) {
            if (typeof c === 'string' && c.includes('||')) {
                const parts = c.split('||');
                return parts.length >= 2 ? parts[1] : c;
            }
            return c;
        }

        // Helper: Normalize source file paths for cross-version comparison
        // Handles:
        //   1. Absolute: C:\Projects\Diablo2\Source\D2Common\DATATBLS\File.cpp -> datatbls/file.cpp
        //   2. Relative: .\GAME\File.cpp or ?.\Src\File.cpp -> game/file.cpp
        function normalizeStringPath(s) {
            // First extract the value from address|name|value format
            s = extractStringValue(s);

            // Only normalize source file paths
            if (!/\.(cpp|c|h)$/i.test(s)) return s;

            // Normalize backslashes to forward slashes
            s = s.replace(/\\\\/g, '/').replace(/\\/g, '/');

            // Strip absolute path prefix (1.00-1.13d format)
            // C:/Projects/Diablo2/Source/{Module}/{subdir}/{file}
            const absMatch = s.match(/^[A-Za-z]:\/[^\/]+\/Diablo2\/Source\/[^\/]+\/(.+)/i);
            if (absMatch) return absMatch[1].toLowerCase();

            // Strip relative path prefix (1.14x format)
            // ./{subdir}/{file} or ?./... or X./...
            const relMatch = s.match(/^[A-Za-z\?]?\.\/(.+)/);
            if (relMatch) return relMatch[1].toLowerCase();

            // Generic: keep last 2 path components
            const parts = s.split('/');
            if (parts.length > 2) return parts.slice(-2).join('/').toLowerCase();
            if (parts.length === 2) return parts.join('/').toLowerCase();

            return s.toLowerCase();
        }

        // Helper: Extract global value from "address|name|value" format
        function extractGlobalValue(g) {
            if (typeof g === 'string' && g.includes('|')) {
                const parts = g.split('|');
                // Format: address|name|value - return value (last part)
                if (parts.length >= 3) return parts[2];
                if (parts.length === 2) return parts[1];
            }
            return g;
        }

        // Helper: Extract instruction mnemonic from instruction data
        // Handles various formats: "0x1234: PUSH EBP" or {address: "0x1234", mnemonic: "PUSH", ...}
        function extractInstructionMnemonic(instr) {
            if (typeof instr === 'string') {
                // Format: "0x1234: PUSH EBP" or "PUSH EBP"
                const colonIdx = instr.indexOf(':');
                const instrPart = colonIdx >= 0 ? instr.substring(colonIdx + 1).trim() : instr.trim();
                // Get first word (the mnemonic)
                const spaceIdx = instrPart.indexOf(' ');
                return spaceIdx >= 0 ? instrPart.substring(0, spaceIdx).toUpperCase() : instrPart.toUpperCase();
            }
            if (typeof instr === 'object' && instr.mnemonic) {
                return instr.mnemonic.toUpperCase();
            }
            return String(instr).toUpperCase();
        }

        // Helper: Compute Jaccard similarity between two sets (intersection / union)
        function computeJaccardSimilarity(set1, set2) {
            if (set1.size === 0 && set2.size === 0) return 1.0;  // Both empty = perfect match
            if (set1.size === 0 || set2.size === 0) return 0.0;  // One empty = no match

            const intersection = [...set1].filter(x => set2.has(x)).length;
            const union = new Set([...set1, ...set2]).size;

            return union > 0 ? intersection / union : 0;
        }

        // Common constants to filter out (too ubiquitous to be meaningful)
        const COMMON_CONSTANTS = new Set([
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '16', '32', '64', '128', '256',
            '0x0', '0x1', '0x2', '0x4', '0x8', '0x10', '0x20', '0x40', '0x80', '0x100',
            '0xFF', '0xFFFF', '0xFFFFFFFF', '-1', '0xffffffff'
        ]);

        // Value match bonus configuration
        const VALUE_BONUS_CONFIG = {
            string_overlap: { max_bonus: 10, min_items: 1 },   // Strings are highly distinctive
            instruction_overlap: { max_bonus: 8, min_items: 3 },   // Instruction patterns
            constant_overlap: { max_bonus: 5, min_items: 2 },   // Constants (filtered)
            global_overlap: { max_bonus: 5, min_items: 1 },   // Global values
            tag_overlap: { max_bonus: 5, min_items: 1 }    // Function tags
        };

        // Compute value-based match bonuses
        // Returns { totalBonus, breakdown: { type: { jaccard, bonus, matched, total } } }
        function computeValueMatchBonuses(sourceData, targetData, sourceVersion, targetVersion) {
            const breakdown = {};
            let totalBonus = 0;

            // 1. String value overlap
            const srcStrings = (sourceData.strings?.[sourceVersion] || []).map(normalizeStringPath);
            const tgtStrings = (targetData.strings?.[targetVersion] || []).map(normalizeStringPath);
            if (srcStrings.length >= VALUE_BONUS_CONFIG.string_overlap.min_items &&
                tgtStrings.length >= VALUE_BONUS_CONFIG.string_overlap.min_items) {
                const srcSet = new Set(srcStrings);
                const tgtSet = new Set(tgtStrings);
                const jaccard = computeJaccardSimilarity(srcSet, tgtSet);
                const bonus = jaccard * VALUE_BONUS_CONFIG.string_overlap.max_bonus;
                const matched = [...srcSet].filter(x => tgtSet.has(x));
                breakdown.string_overlap = {
                    jaccard: Math.round(jaccard * 100),
                    bonus: Math.round(bonus * 10) / 10,
                    matched: matched.slice(0, 3),  // Top 3 for display
                    srcCount: srcStrings.length,
                    tgtCount: tgtStrings.length
                };
                totalBonus += bonus;
            }

            // 2. Instruction mnemonic overlap
            const srcInstrs = (sourceData.instructions?.[sourceVersion] || []).map(extractInstructionMnemonic);
            const tgtInstrs = (targetData.instructions?.[targetVersion] || []).map(extractInstructionMnemonic);
            if (srcInstrs.length >= VALUE_BONUS_CONFIG.instruction_overlap.min_items &&
                tgtInstrs.length >= VALUE_BONUS_CONFIG.instruction_overlap.min_items) {
                // Use multiset comparison (count occurrences)
                const srcCounts = new Map();
                const tgtCounts = new Map();
                srcInstrs.forEach(m => srcCounts.set(m, (srcCounts.get(m) || 0) + 1));
                tgtInstrs.forEach(m => tgtCounts.set(m, (tgtCounts.get(m) || 0) + 1));

                // Intersection: min of counts for each mnemonic
                let intersectionSize = 0;
                for (const [mnem, srcCount] of srcCounts) {
                    const tgtCount = tgtCounts.get(mnem) || 0;
                    intersectionSize += Math.min(srcCount, tgtCount);
                }
                const unionSize = Math.max(srcInstrs.length, tgtInstrs.length);
                const jaccard = unionSize > 0 ? intersectionSize / unionSize : 0;
                const bonus = jaccard * VALUE_BONUS_CONFIG.instruction_overlap.max_bonus;
                breakdown.instruction_overlap = {
                    jaccard: Math.round(jaccard * 100),
                    bonus: Math.round(bonus * 10) / 10,
                    srcCount: srcInstrs.length,
                    tgtCount: tgtInstrs.length
                };
                totalBonus += bonus;
            }

            // 3. Constant value overlap (filter common constants)
            const srcConstants = (sourceData.constants?.[sourceVersion] || [])
                .map(extractConstantValue)
                .filter(c => !COMMON_CONSTANTS.has(String(c)));
            const tgtConstants = (targetData.constants?.[targetVersion] || [])
                .map(extractConstantValue)
                .filter(c => !COMMON_CONSTANTS.has(String(c)));
            if (srcConstants.length >= VALUE_BONUS_CONFIG.constant_overlap.min_items &&
                tgtConstants.length >= VALUE_BONUS_CONFIG.constant_overlap.min_items) {
                const srcSet = new Set(srcConstants.map(String));
                const tgtSet = new Set(tgtConstants.map(String));
                const jaccard = computeJaccardSimilarity(srcSet, tgtSet);
                const bonus = jaccard * VALUE_BONUS_CONFIG.constant_overlap.max_bonus;
                const matched = [...srcSet].filter(x => tgtSet.has(x));
                breakdown.constant_overlap = {
                    jaccard: Math.round(jaccard * 100),
                    bonus: Math.round(bonus * 10) / 10,
                    matched: matched.slice(0, 3),
                    srcCount: srcConstants.length,
                    tgtCount: tgtConstants.length
                };
                totalBonus += bonus;
            }

            // 4. Global value overlap
            const srcGlobals = (sourceData.globals?.[sourceVersion] || []).map(extractGlobalValue);
            const tgtGlobals = (targetData.globals?.[targetVersion] || []).map(extractGlobalValue);
            if (srcGlobals.length >= VALUE_BONUS_CONFIG.global_overlap.min_items &&
                tgtGlobals.length >= VALUE_BONUS_CONFIG.global_overlap.min_items) {
                const srcSet = new Set(srcGlobals.map(String));
                const tgtSet = new Set(tgtGlobals.map(String));
                const jaccard = computeJaccardSimilarity(srcSet, tgtSet);
                const bonus = jaccard * VALUE_BONUS_CONFIG.global_overlap.max_bonus;
                const matched = [...srcSet].filter(x => tgtSet.has(x));
                breakdown.global_overlap = {
                    jaccard: Math.round(jaccard * 100),
                    bonus: Math.round(bonus * 10) / 10,
                    matched: matched.slice(0, 3),
                    srcCount: srcGlobals.length,
                    tgtCount: tgtGlobals.length
                };
                totalBonus += bonus;
            }

            // 5. Tag overlap
            const srcTags = sourceData.tags?.[sourceVersion] || [];
            const tgtTags = targetData.tags?.[targetVersion] || [];
            if (srcTags.length >= VALUE_BONUS_CONFIG.tag_overlap.min_items &&
                tgtTags.length >= VALUE_BONUS_CONFIG.tag_overlap.min_items) {
                const srcSet = new Set(srcTags);
                const tgtSet = new Set(tgtTags);
                const jaccard = computeJaccardSimilarity(srcSet, tgtSet);
                const bonus = jaccard * VALUE_BONUS_CONFIG.tag_overlap.max_bonus;
                const matched = [...srcSet].filter(x => tgtSet.has(x));
                breakdown.tag_overlap = {
                    jaccard: Math.round(jaccard * 100),
                    bonus: Math.round(bonus * 10) / 10,
                    matched: matched,
                    srcCount: srcTags.length,
                    tgtCount: tgtTags.length
                };
                totalBonus += bonus;
            }

            return {
                totalBonus: Math.round(totalBonus * 10) / 10,
                breakdown
            };
        }

        // Build rarity index from function data
        // Counts how often each callee/string/constant appears across all functions
        function buildRarityIndex(funcData) {
            const calleeCount = new Map();
            const stringCount = new Map();
            const constantCount = new Map();
            const totalFunctions = Object.keys(funcData.functions).length;

            for (const [key, func] of Object.entries(funcData.functions)) {
                // Count callees across all versions
                if (func.callees) {
                    const seenCallees = new Set();
                    for (const version of Object.keys(func.callees)) {
                        for (const callee of func.callees[version]) {
                            const name = callee.name || callee;
                            if (!seenCallees.has(name)) {
                                seenCallees.add(name);
                                calleeCount.set(name, (calleeCount.get(name) || 0) + 1);
                            }
                        }
                    }
                }

                // Count strings across all versions (normalize paths for cross-version matching)
                if (func.strings) {
                    const seenStrings = new Set();
                    for (const version of Object.keys(func.strings)) {
                        for (const str of func.strings[version]) {
                            // Use normalizeStringPath for path normalization (handles .cpp/.c/.h files)
                            const strValue = normalizeStringPath(str);
                            if (!seenStrings.has(strValue)) {
                                seenStrings.add(strValue);
                                stringCount.set(strValue, (stringCount.get(strValue) || 0) + 1);
                            }
                        }
                    }
                }

                // Count constants across all versions (extract value from address||value format)
                if (func.constants) {
                    const seenConstants = new Set();
                    for (const version of Object.keys(func.constants)) {
                        for (const c of func.constants[version]) {
                            const cValue = extractConstantValue(c);
                            if (!seenConstants.has(cValue)) {
                                seenConstants.add(cValue);
                                constantCount.set(cValue, (constantCount.get(cValue) || 0) + 1);
                            }
                        }
                    }
                }
            }

            // Convert to rarity scores: 1 / log(count + 1)
            // Lower count = higher rarity = higher score
            const calleeRarity = new Map();
            const stringRarity = new Map();
            const constantRarity = new Map();

            for (const [name, count] of calleeCount) {
                calleeRarity.set(name, 1 / Math.log2(count + 1));
            }
            for (const [str, count] of stringCount) {
                stringRarity.set(str, 1 / Math.log2(count + 1));
            }
            for (const [c, count] of constantCount) {
                // Filter out very common constants (0, 1, 2, 4, 8, etc.)
                if (count > totalFunctions * 0.5) {
                    constantRarity.set(c, 0.01); // Very low rarity for ubiquitous constants
                } else {
                    constantRarity.set(c, 1 / Math.log2(count + 1));
                }
            }

            return {
                callees: calleeRarity,
                strings: stringRarity,
                constants: constantRarity,
                totalFunctions
            };
        }

        // Calculate tiered identity match
        // Returns { tier, confidence, breakdown, warnings }
        function calculateTieredMatch(sourceData, targetData, sourceVersion, targetVersion, rarityIdx) {
            const result = {
                tier: 0,
                confidence: 0,
                breakdown: {
                    tier1: { matched: false, reason: null },
                    tier2: { score: 0, matchedItems: [], totalRarity: 0 },
                    tier3: { plausible: true, warnings: [] }
                },
                warnings: []
            };

            // Extract data for comparison
            const sourceCallees = sourceData.callees?.[sourceVersion] || [];
            const targetCallees = targetData.callees?.[targetVersion] || [];
            const sourceStrings = sourceData.strings?.[sourceVersion] || [];
            const targetStrings = targetData.strings?.[targetVersion] || [];
            const sourceConstants = sourceData.constants?.[sourceVersion] || [];
            const targetConstants = targetData.constants?.[targetVersion] || [];
            const sourceSize = sourceData.sizes?.[sourceVersion] || 0;
            const targetSize = targetData.sizes?.[targetVersion] || 0;
            const sourceMnemonicHash = sourceData.mnemonic_hashes?.[sourceVersion] || '';
            const targetMnemonicHash = targetData.mnemonic_hashes?.[targetVersion] || '';
            const sourceIndex = sourceData.index || '';
            const targetIndex = targetData.index || '';

            // ========== TIER 1: Definitive Matches ==========
            // Mnemonic hash match - identical opcode sequence
            if (sourceMnemonicHash && targetMnemonicHash && sourceMnemonicHash === targetMnemonicHash) {
                result.tier = 1;
                result.confidence = 100;
                result.breakdown.tier1 = { matched: true, reason: 'Mnemonic hash match (identical opcodes)' };
                return result;
            }

            // Index hash match (API/EXP/STR signature)
            if (sourceIndex && targetIndex && sourceIndex === targetIndex) {
                result.tier = 1;
                result.confidence = 98;
                result.breakdown.tier1 = { matched: true, reason: `Index hash match (${sourceIndex.split(':')[0]})` };
                return result;
            }

            // Exact callee count + exact size match (count-based, not name-based)
            // Only consider definitive if both have meaningful callee counts
            if (sourceCallees.length > 2 && sourceCallees.length === targetCallees.length && sourceSize === targetSize) {
                // Additional check: string counts should also match
                const srcStringCount = sourceStrings.length;
                const tgtStringCount = targetStrings.length;
                if (srcStringCount === tgtStringCount && srcStringCount > 0) {
                    result.tier = 1;
                    result.confidence = 95;
                    result.breakdown.tier1 = { matched: true, reason: `Exact counts match (size:${sourceSize}, callees:${sourceCallees.length}, strings:${srcStringCount})` };
                    return result;
                }
            }

            // ========== TIER 2: Count-Based Vector Similarity ==========
            // Use structural count metrics (not names) for reliable cross-version matching
            const vectorResult = computeCountVectorSimilarity(sourceData, targetData, sourceVersion, targetVersion);

            // Calculate tier 2 score from vector similarity
            const tier2Score = vectorResult.score || 0;

            // Build list of best matching features for display
            const matchedItems = [];
            if (vectorResult.breakdown && !vectorResult.error) {
                // Sort features by contribution (highest first)
                const sortedFeatures = Object.entries(vectorResult.breakdown)
                    .sort((a, b) => b[1].contribution - a[1].contribution)
                    .slice(0, 5);

                for (const [feat, data] of sortedFeatures) {
                    if (data.similarity >= 50) {  // Only show decent matches
                        matchedItems.push({
                            type: 'count',
                            name: `${feat}: ${data.val1} vs ${data.val2}`,
                            rarity: `${data.similarity}%`
                        });
                    }
                }
            }

            // ========== VALUE MATCH BONUSES ==========
            // Add bonuses for matching values (strings, constants, globals, instructions, tags)
            const valueBonuses = computeValueMatchBonuses(sourceData, targetData, sourceVersion, targetVersion);

            // Add value-matched items to the display list
            if (valueBonuses.breakdown.string_overlap?.matched?.length > 0) {
                for (const str of valueBonuses.breakdown.string_overlap.matched) {
                    matchedItems.push({ type: 'string', name: str.substring(0, 30), rarity: `+${valueBonuses.breakdown.string_overlap.bonus}` });
                }
            }
            if (valueBonuses.breakdown.constant_overlap?.matched?.length > 0) {
                for (const c of valueBonuses.breakdown.constant_overlap.matched) {
                    matchedItems.push({ type: 'constant', name: c, rarity: `+${valueBonuses.breakdown.constant_overlap.bonus}` });
                }
            }

            result.breakdown.tier2 = {
                score: Math.round(tier2Score),
                valueBonus: valueBonuses.totalBonus,
                combinedScore: Math.min(100, Math.round(tier2Score + valueBonuses.totalBonus)),
                matchedItems: matchedItems.slice(0, 8),  // Top 8 items
                vectorBreakdown: vectorResult.breakdown || {},
                valueBonusBreakdown: valueBonuses.breakdown || {},
                featureCount: vectorResult.featureCount || 0,
                method: 'count_vector_plus_values'
            };

            // ========== TIER 3: Structural Validation ==========
            // Check if structure is plausible
            if (sourceSize > 0 && targetSize > 0) {
                const sizeRatio = Math.min(sourceSize, targetSize) / Math.max(sourceSize, targetSize);
                if (sizeRatio < 0.5) {
                    result.breakdown.tier3.plausible = false;
                    result.breakdown.tier3.warnings.push(`Size mismatch: ${sourceSize} vs ${targetSize} (${Math.round(sizeRatio * 100)}%)`);
                    result.warnings.push('⚠️ Size differs by >50%');
                } else if (sizeRatio < 0.8) {
                    result.breakdown.tier3.warnings.push(`Size differs: ${sourceSize} vs ${targetSize} (${Math.round(sizeRatio * 100)}%)`);
                    result.warnings.push('Size differs by >20%');
                }
            }

            // Check callee count plausibility
            if (sourceCallees.length > 0 && targetCallees.length > 0) {
                const calleeRatio = Math.min(sourceCallees.length, targetCallees.length) /
                    Math.max(sourceCallees.length, targetCallees.length);
                if (calleeRatio < 0.5) {
                    result.breakdown.tier3.warnings.push(`Callee count mismatch: ${sourceCallees.length} vs ${targetCallees.length}`);
                }
            }

            // ========== Final Scoring ==========
            // Use combined score (base vector + value bonuses), capped at 100
            let finalScore = Math.min(100, tier2Score + valueBonuses.totalBonus);

            // Apply tier 3 penalties
            if (!result.breakdown.tier3.plausible) {
                finalScore *= 0.5;  // Heavy penalty for implausible structure
            } else if (result.breakdown.tier3.warnings.length > 0) {
                finalScore *= 0.85;  // Minor penalty for structural differences
            }

            // Determine tier based on final score
            if (finalScore >= 70) {
                result.tier = 2;
                result.confidence = Math.min(90, Math.round(finalScore));
            } else if (finalScore >= 40) {
                result.tier = 2;
                result.confidence = Math.round(finalScore);
            } else {
                result.tier = 3;
                result.confidence = Math.round(finalScore);
            }

            return result;
        }

        // Wrapper function that adapts calculateTieredMatch to the expected interface
        // Expected by showComparePanel: { score, tier, tierName, details, warnings }
        function calculateIdentityMatch(sourceObj, targetObj, sourceVersion, targetVersion) {
            // Transform flat objects to the nested structure expected by calculateTieredMatch
            // Include all count fields for count-based vector similarity
            const sourceData = {
                callees: { [sourceVersion]: sourceObj.callees || [] },
                strings: { [sourceVersion]: sourceObj.strings || [] },
                constants: { [sourceVersion]: sourceObj.constants || [] },
                globals: { [sourceVersion]: sourceObj.globals || [] },
                instructions: { [sourceVersion]: sourceObj.instructions || [] },
                tags: { [sourceVersion]: sourceObj.tags || [] },
                sizes: { [sourceVersion]: sourceObj.size || 0 },
                mnemonic_hashes: { [sourceVersion]: sourceObj.mnemonic_hash || '' },
                index: sourceObj.indexes ?
                    (Object.entries(sourceObj.indexes).find(([k, v]) => v)?.[0] + ':' +
                        Object.entries(sourceObj.indexes).find(([k, v]) => v)?.[1]) : '',
                // Count fields for vector similarity
                instruction_counts: { [sourceVersion]: sourceObj.instruction_count || 0 },
                loop_counts: { [sourceVersion]: sourceObj.loop_count || 0 },
                stack_frame_sizes: { [sourceVersion]: sourceObj.stack_frame_size || 0 },
                callee_counts: { [sourceVersion]: sourceObj.callee_count || (sourceObj.callees?.length || 0) },
                caller_counts: { [sourceVersion]: sourceObj.caller_count || (sourceObj.callers?.length || 0) },
                string_counts: { [sourceVersion]: sourceObj.string_count || (sourceObj.strings?.length || 0) },
                constant_counts: { [sourceVersion]: sourceObj.constant_count || (sourceObj.constants?.length || 0) },
                global_counts: { [sourceVersion]: sourceObj.global_count || (sourceObj.globals?.length || 0) },
                api_counts: { [sourceVersion]: sourceObj.api_count || (sourceObj.api_calls?.length || 0) },
                param_counts: { [sourceVersion]: sourceObj.param_count || 0 }
            };

            const targetData = {
                callees: { [targetVersion]: targetObj.callees || [] },
                strings: { [targetVersion]: targetObj.strings || [] },
                constants: { [targetVersion]: targetObj.constants || [] },
                globals: { [targetVersion]: targetObj.globals || [] },
                instructions: { [targetVersion]: targetObj.instructions || [] },
                tags: { [targetVersion]: targetObj.tags || [] },
                sizes: { [targetVersion]: targetObj.size || 0 },
                mnemonic_hashes: { [targetVersion]: targetObj.mnemonic_hash || '' },
                index: targetObj.indexes ?
                    (Object.entries(targetObj.indexes).find(([k, v]) => v)?.[0] + ':' +
                        Object.entries(targetObj.indexes).find(([k, v]) => v)?.[1]) : '',
                // Count fields for vector similarity
                instruction_counts: { [targetVersion]: targetObj.instruction_count || 0 },
                loop_counts: { [targetVersion]: targetObj.loop_count || 0 },
                stack_frame_sizes: { [targetVersion]: targetObj.stack_frame_size || 0 },
                callee_counts: { [targetVersion]: targetObj.callee_count || (targetObj.callees?.length || 0) },
                caller_counts: { [targetVersion]: targetObj.caller_count || (targetObj.callers?.length || 0) },
                string_counts: { [targetVersion]: targetObj.string_count || (targetObj.strings?.length || 0) },
                constant_counts: { [targetVersion]: targetObj.constant_count || (targetObj.constants?.length || 0) },
                global_counts: { [targetVersion]: targetObj.global_count || (targetObj.globals?.length || 0) },
                api_counts: { [targetVersion]: targetObj.api_count || (targetObj.api_calls?.length || 0) },
                param_counts: { [targetVersion]: targetObj.param_count || 0 }
            };

            // Call the tiered match function
            const tieredResult = calculateTieredMatch(sourceData, targetData, sourceVersion, targetVersion, rarityIndex);

            // Map tier number to tier name
            const tierNames = {
                1: 'Tier 1: Definitive',
                2: 'Tier 2: Strong Fingerprint',
                3: 'Tier 3: Structural'
            };

            // Check for mnemonic/index matches from tier 1 breakdown
            const mnemonicMatch = tieredResult.breakdown.tier1.matched &&
                tieredResult.breakdown.tier1.reason?.includes('Mnemonic');
            const indexMatch = tieredResult.breakdown.tier1.matched &&
                tieredResult.breakdown.tier1.reason?.includes('Index');

            // Transform to expected format
            return {
                score: tieredResult.confidence,
                tier: tieredResult.tier,
                tierName: tierNames[tieredResult.tier] || 'Unknown',
                details: {
                    vectorScore: tieredResult.breakdown.tier2.score || 0,
                    mnemonicMatch: mnemonicMatch,
                    indexMatch: indexMatch,
                    matchedItems: tieredResult.breakdown.tier2.matchedItems || [],
                    vectorBreakdown: tieredResult.breakdown.tier2.vectorBreakdown || {},
                    featureCount: tieredResult.breakdown.tier2.featureCount || 0,
                    tier1Reason: tieredResult.breakdown.tier1.reason,
                    plausible: tieredResult.breakdown.tier3.plausible,
                    method: tieredResult.breakdown.tier2.method || 'count_vector'
                },
                warnings: tieredResult.warnings || []
            };
        }

        // Function data cache (loaded on demand) - keyed by "filename.group"
        const loadedFunctionData = {};

        // Case-insensitive lookup helper for FUNCTION_INDEX
        function findFunctionIndexFile(filename) {
            if (typeof FUNCTION_INDEX === 'undefined' || !FUNCTION_INDEX.files) return null;
            // Direct match first
            if (FUNCTION_INDEX.files[filename]) return filename;
            // Case-insensitive search
            const lowerName = filename.toLowerCase();
            for (const key of Object.keys(FUNCTION_INDEX.files)) {
                if (key.toLowerCase() === lowerName) return key;
            }
            return null;
        }

        // Get the active version group based on filter state
        // Priority: If only one filter is active, use that. Otherwise prefer the most relevant.
        function getActiveVersionGroup() {
            const activeCount = Object.values(versionFilters).filter(v => v).length;

            // If only one is active, use that one
            if (activeCount === 1) {
                if (versionFilters.preRefactor) return 'pre';
                if (versionFilters.postRefactor) return 'post';
                if (versionFilters.lod) return 'lod';
            }

            // If multiple are active, pick based on priority (lod > post > pre for most data)
            if (versionFilters.lod) return 'lod';
            if (versionFilters.postRefactor) return 'post';
            if (versionFilters.preRefactor) return 'pre';

            return 'post'; // Default fallback
        }

        // Load function data for a specific file and version group
        // Old loadFunctionData function removed - now handled by async API version above


        // Note: CATEGORIES moved to API loading section above

        // Category filter state - all enabled by default
        let categoryFilters = {};
        Object.keys(CATEGORIES).forEach(cat => categoryFilters[cat] = true);

        // Simplified version loading for debugging
        async function loadVersionsOnly() {
            try {
                console.log('Loading versions only...');
                const response = await fetch(`${API_BASE_URL}/versions`);
                if (!response.ok) throw new Error('Versions API failed');

                const rawVersions = await response.json();
                console.log('Got versions:', rawVersions.length);

                VERSIONS_DATA = rawVersions.map(v => ({
                    folder_name: `${v.versionFamily}/${v.versionString}`,
                    game_type: v.versionFamily,
                    version: v.versionString,
                    file_count: 0, // Will be populated from binaries API
                    change_count: 0, // Will be populated from binaries API
                    is_lod: v.versionFamily === 'LoD',
                    raw_pe_version: v.versionString,
                    total_size_readable: 'Unknown',
                    nocd_status: 'unknown',
                    description: v.description,
                    created_at: v.createdAt,
                    id: v.id
                }));

                console.log('Transformed VERSIONS_DATA:', VERSIONS_DATA.length);
                return true;
            } catch (error) {
                console.error('Failed to load versions:', error);
                return false;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async function () {
            console.log('DOM loaded, starting simplified initialization...');

            // Try simplified version loading first
            const versionsLoaded = await loadVersionsOnly();
            if (versionsLoaded && VERSIONS_DATA.length > 0) {
                console.log('Versions loaded successfully, rendering...');
                renderVersionList();
                return;
            }

            // Fallback to full API loading
            console.log('Falling back to full API loading...');
            const dataLoaded = await loadAPIData();
            console.log('Data loaded result:', dataLoaded, 'VERSIONS_DATA.length:', VERSIONS_DATA.length);
            if (!dataLoaded || !VERSIONS_DATA.length) {
                console.error('Failed to load API data - dataLoaded:', dataLoaded, 'versions:', VERSIONS_DATA.length);
                showErrorToast('Failed to load BSim data from API');
                return;
            }
            console.log('Proceeding with UI initialization...');

            // Update footer stats
            document.getElementById('statVersions').textContent = VERSIONS_DATA.length;
            document.getElementById('statFiles').textContent = Object.keys(FILE_HISTORY_DATA || {}).length;

            // Count total variants
            let totalVariants = 0;
            Object.values(FILE_HISTORY_DATA || {}).forEach(f => {
                totalVariants += f.variant_count || 0;
            });
            document.getElementById('statHashes').textContent = totalVariants;

            updateFilterButtons();
            console.log('About to render version list with', VERSIONS_DATA.length, 'versions');
            renderVersionList();
        });

        function toggleVersionFilter(filterKey) {
            // Toggle the specific filter
            versionFilters[filterKey] = !versionFilters[filterKey];

            // Ensure at least one filter is active
            const anyActive = Object.values(versionFilters).some(v => v);
            if (!anyActive) {
                versionFilters[filterKey] = true;
            }

            // Update legacy flags for compatibility
            showClassic = versionFilters.preRefactor || versionFilters.postRefactor;
            showLoD = versionFilters.lod;

            updateFilterButtons();
            renderVersionList();

            // Refresh file details panel - reload function data for new group
            if (selectedFile) {
                const fileInfo = null; // File info now comes from binaries API
                const baseName = selectedFile.split(' (')[0];
                const history = FILE_HISTORY_DATA[baseName];

                // Clear cached function data for this file to force reload with new group
                currentFuncData = null;

                renderFileDetails(selectedFile, fileInfo, history);
            }
        }

        // Helper to filter versions by filter state
        function filterVersionsByType(versions) {
            // Always return all versions - no filtering
            return versions;
        }

        // Get active filter names for display
        function getActiveFilterNames() {
            const names = [];
            if (versionFilters.preRefactor) names.push('Pre');
            if (versionFilters.postRefactor) names.push('Post');
            if (versionFilters.lod) names.push('LoD');
            return names;
        }

        function updateFilterButtons() {
            // Update each button's active state
            document.querySelector('.filter-btn.pre-refactor')?.classList.toggle('active', versionFilters.preRefactor);
            document.querySelector('.filter-btn.post-refactor')?.classList.toggle('active', versionFilters.postRefactor);
            document.querySelector('.filter-btn.lod')?.classList.toggle('active', versionFilters.lod);
        }

        function renderCategoryFilters() {
            const container = document.getElementById('categoryFilters');
            if (!container) return;

            container.innerHTML = Object.entries(CATEGORIES).map(([name, info]) => `
                <button class="category-btn ${categoryFilters[name] ? 'active' : ''}"
                        style="color: ${info.color}"
                        onclick="toggleCategoryFilter('${name}')"
                        title="${name}">
                    <span class="full-text">${name}</span>
                    <span class="short-text">${info.short}</span>
                </button>
            `).join('');
        }

        function toggleCategoryFilter(category) {
            categoryFilters[category] = !categoryFilters[category];

            // Ensure at least one category is active
            const anyActive = Object.values(categoryFilters).some(v => v);
            if (!anyActive) {
                categoryFilters[category] = true;
            }

            renderCategoryFilters();
            // Note: Files are now rendered via renderBinariesTable() in selectVersion()
        }

        function toggleGrouping() {
            isGrouped = !isGrouped;
            document.getElementById('groupBtn').classList.toggle('active', isGrouped);
            // Note: Files are now rendered via renderBinariesTable() in selectVersion()
        }

        function toggleCategory(categoryName) {
            collapsedCategories[categoryName] = !collapsedCategories[categoryName];

            // Update header appearance
            const header = document.querySelector(`[data-category="${categoryName}"]`);
            if (header) {
                header.classList.toggle('collapsed', collapsedCategories[categoryName]);

                // Update toggle arrow
                const toggle = header.querySelector('.category-toggle');
                if (toggle) {
                    toggle.textContent = collapsedCategories[categoryName] ? '▶' : '▼';
                }
            }

            // Update files visibility
            const files = document.querySelector(`.category-files[data-category="${categoryName}"]`);
            if (files) {
                files.classList.toggle('collapsed', collapsedCategories[categoryName]);
            }
        }

        function renderVersionList() {
            console.log('renderVersionList called with', VERSIONS_DATA.length, 'versions');
            const container = document.getElementById('versionList');
            console.log('Version container element:', container ? 'found' : 'NOT FOUND');

            // Show all versions - no filtering
            let versions = VERSIONS_DATA;

            // Sort by version number
            versions.sort((a, b) => {
                const parseVer = (v) => {
                    if (!v || !v.version) return [0, 0, '', 999];
                    const match = v.version.match(/^(\d+)\.(\d+)([a-z])?(?:\s*Beta\s*(\d+))?$/i);
                    if (!match) return [0, 0, '', 999];
                    return [
                        parseInt(match[1]),
                        parseInt(match[2]),
                        match[3] || '',
                        match[4] ? parseInt(match[4]) : 999
                    ];
                };
                const [aMaj, aMin, aLet, aBeta] = parseVer(a);
                const [bMaj, bMin, bLet, bBeta] = parseVer(b);

                if (aMaj !== bMaj) return aMaj - bMaj;
                if (aMin !== bMin) return aMin - bMin;
                if (aBeta !== bBeta) return aBeta - bBeta;
                return aLet.localeCompare(bLet);
            });

            container.innerHTML = versions.map(v => {
                const isClassic = v.game_type === 'Classic';
                const typeClass = isClassic ? 'classic' : 'lod';
                const changeCount = v.change_count || 0;
                const totalFiles = v.file_count || 0;
                const isSelected = selectedVersion === v.folder_name;

                // Format: "changed / total" or "— / total" if no changes tracked
                const changedDisplay = changeCount > 0 ? `<span class="changed">${changeCount}</span>` : '<span>—</span>';
                const countsHtml = `${changedDisplay}<span class="separator"> / </span><span class="total">${totalFiles}</span>`;

                return `
                    <div class="version-item ${isSelected ? 'selected' : ''}"
                         onclick="selectVersion('${v.folder_name}')"
                         title="${v.game_type} ${v.version} - ${changeCount} of ${totalFiles} files changed">
                        <span class="version-badge ${typeClass}">${v.version}</span>
                    </div>
                `;
            }).join('');
        }

        async function selectVersion(folderName) {
            console.log('selectVersion called with:', folderName);

            // Remember the previously selected file (base name without variant suffix)
            const previousFile = selectedFile;
            const previousFileBase = previousFile ? previousFile.split(' (')[0] : null;

            selectedVersion = folderName;

            // Update version list selection
            document.querySelectorAll('.version-item').forEach(el => {
                el.classList.toggle('selected', el.getAttribute('onclick').includes(folderName));
            });

            // Extract gameType and version from folderName (e.g., "Classic/1.01")
            const [gameType, version] = folderName.split('/');
            console.log('Loading binaries for:', gameType, version);

            try {
                // Load binaries from API
                const response = await fetch(`${API_BASE_URL}/binaries?gameType=${gameType}&version=${version}`);
                if (!response.ok) {
                    console.error('Failed to fetch binaries:', response.status);
                    document.getElementById('filesTable').innerHTML = '<div class="details-empty">Failed to load binaries</div>';
                    return;
                }

                const binaries = await response.json();
                console.log('Loaded binaries:', binaries.length);

                if (binaries.length === 0) {
                    document.getElementById('filesTable').innerHTML = '<div class="details-empty">No binaries found for this version</div>';
                    return;
                }

                // Show toolbar and filter
                document.getElementById('filesToolbar').style.display = 'flex';
                document.getElementById('filesFilter').style.display = 'block';
                document.getElementById('filesFilter').value = '';

                // Render binaries
                renderBinariesTable(binaries);

            } catch (error) {
                console.error('Error loading binaries:', error);
                document.getElementById('filesTable').innerHTML = '<div class="details-empty">Error loading binaries</div>';
            }
        }

        function renderBinariesTable(binaries) {
            const container = document.getElementById('filesTable');
            const filterText = document.getElementById('filesFilter')?.value.toLowerCase() || '';

            if (!binaries || binaries.length === 0) {
                container.innerHTML = '<div class="details-empty">No binaries found</div>';
                return;
            }

            // Filter by text if filter exists
            let filteredBinaries = binaries;
            if (filterText) {
                filteredBinaries = binaries.filter(b => b.fileName.toLowerCase().includes(filterText));
            }

            // Filter by category
            filteredBinaries = filteredBinaries.filter(binary => {
                const category = binary.category || 'Other';
                return categoryFilters[category];
            });

            if (filteredBinaries.length === 0) {
                container.innerHTML = '<div class="details-empty">No files match the filter</div>';
                return;
            }

            // Convert to [filename, file] format for compatibility
            const files = filteredBinaries.map(b => [b.fileName, b]);
            const fileCount = files.length;

            if (isGrouped) {
                // Group by category
                const grouped = {};
                files.forEach(([filename, file]) => {
                    const category = file.category || 'Other';
                    if (!grouped[category]) {
                        grouped[category] = [];
                    }
                    grouped[category].push([filename, file]);
                });

                // Sort categories by defined order, sort files within each category
                const categoryOrder = Object.keys(CATEGORIES);
                const sortedCategories = Object.keys(grouped).sort((a, b) => {
                    return categoryOrder.indexOf(a) - categoryOrder.indexOf(b);
                });

                let html = '';
                sortedCategories.forEach(category => {
                    const categoryFiles = grouped[category].sort((a, b) => a[0].localeCompare(b[0]));
                    const categoryInfo = CATEGORIES[category] || { color: '#FFFFFF', short: '??' };

                    // Category header with column headers
                    html += `
                        <div class="category-header" onclick="toggleCategory('${category}')" data-category="${category}">
                            <span class="category-toggle">▼</span>
                            <span class="category-dot" style="background-color: ${categoryInfo.color}"></span>
                            <span class="category-name">${category}</span>
                            <span class="column-header hash">Hash</span>
                        </div>
                    `;

                    // Files in this category
                    html += `<div class="category-files" data-category="${category}">`;
                    html += categoryFiles.map(([filename, file]) => renderBinaryRow(filename, file)).join('');
                    html += `</div>`;
                });

                container.innerHTML = html;
            } else {
                // Table header row (only in non-grouped mode)
                const tableHeader = `
                    <div class="table-header">
                        <span></span>
                        <span>${fileCount} Files</span>
                        <span>Hash</span>
                    </div>
                `;
                // Sort alphabetically
                files.sort((a, b) => a[0].localeCompare(b[0]));
                container.innerHTML = tableHeader + files.map(([filename, file]) => renderBinaryRow(filename, file)).join('');
            }
        }

        function renderBinaryRow(filename, file) {
            const categoryColor = CATEGORIES[file.category]?.color || getCategoryColor(file.category);
            const isSelected = selectedFile === filename;

            // Hash display - last 4 characters with copy button (use SHA256)
            const fullHash = file.sha256 || '';
            const shortHash = fullHash ? fullHash.slice(-4) : '—';
            const hashCell = fullHash
                ? `<span class="hash-short" title="${fullHash}">${shortHash}</span><button class="hash-copy-btn" onclick="event.stopPropagation(); copyHash('${fullHash}')" title="Copy full hash">⧉</button>`
                : `<span class="hash-short">—</span>`;

            // Match renderFileRow structure but without displaying file type
            const variantCount = 1; // Binaries typically don't have variants
            const versionId = '—'; // No version info for binaries

            return `
                <div class="file-row ${isSelected ? 'selected' : ''}"
                     onclick="selectFile('${filename.replace(/'/g, "\\'")}')">
                    <div class="category-indicator" style="background-color: ${categoryColor}"></div>
                    <span class="filename" title="${filename}">${filename}</span>
                    <div class="hash-cell">${hashCell}</div>
                </div>
            `;
        }

        function formatFileSize(sizeStr) {
            // For now, just return the MD5 since we don't have size data
            // This could be enhanced to show actual file sizes if available
            return sizeStr ? sizeStr.substring(0, 8) : '';
        }

        function renderFilesTable(folder) {
            const container = document.getElementById('filesTable');
            const filterText = document.getElementById('filesFilter').value.toLowerCase();

            let files = Object.entries(folder.files);

            // Filter by text
            if (filterText) {
                files = files.filter(([name]) => name.toLowerCase().includes(filterText));
            }

            // Filter by category
            files = files.filter(([name, file]) => {
                const category = file.category || 'Other';
                return categoryFilters[category];
            });

            // Store file count for header
            const fileCount = files.length;

            if (files.length === 0) {
                container.innerHTML = '<div class="details-empty">No files match the filter</div>';
                return;
            }

            if (isGrouped) {
                // Group by category
                const grouped = {};
                files.forEach(([filename, file]) => {
                    const category = file.category || 'Other';
                    if (!grouped[category]) {
                        grouped[category] = [];
                    }
                    grouped[category].push([filename, file]);
                });

                // Sort categories by defined order, sort files within each category
                const categoryOrder = Object.keys(CATEGORIES);
                const sortedCategories = Object.keys(grouped).sort((a, b) => {
                    return categoryOrder.indexOf(a) - categoryOrder.indexOf(b);
                });

                let html = '';
                sortedCategories.forEach(category => {
                    const categoryFiles = grouped[category].sort((a, b) => a[0].localeCompare(b[0]));
                    const categoryInfo = CATEGORIES[category] || { color: '#FFFFFF', short: '??' };

                    // Category header with column headers
                    html += `
                        <div class="category-header" onclick="toggleCategory('${category}')" data-category="${category}">
                            <span class="category-toggle">▼</span>
                            <span class="category-dot" style="background-color: ${categoryInfo.color}"></span>
                            <span class="category-name">${category}</span>
                            <span class="column-header hash">Hash</span>
                        </div>
                    `;

                    // Files in this category
                    html += `<div class="category-files" data-category="${category}">`;
                    html += categoryFiles.map(([filename, file]) => renderFileRow(filename, file)).join('');
                    html += `</div>`;
                });

                container.innerHTML = html;
            } else {
                // Table header row (only in non-grouped mode)
                const tableHeader = `
                    <div class="table-header">
                        <span></span>
                        <span>${fileCount} Files</span>
                        <span>Hash</span>
                    </div>
                `;
                // Sort alphabetically
                files.sort((a, b) => a[0].localeCompare(b[0]));
                container.innerHTML = tableHeader + files.map(([filename, file]) => renderFileRow(filename, file)).join('');
            }
        }

        function renderFileRow(filename, file) {
            const categoryColor = file.category_color || getCategoryColor(file.category);
            const versionId = file.pe_version || file.community_id || '—';
            const versionClass = file.pe_version ? 'pe-version' : (file.community_id ? '' : 'static');
            const isSelected = selectedFile === filename;

            // Get variant count from file history
            const baseName = filename.split(' (')[0];
            const history = FILE_HISTORY_DATA[baseName];
            const variantCount = history?.variant_count || 1;
            const variantClass = variantCount > 3 ? 'many' : '';

            // Hash display - last 4 characters with copy button
            const fullHash = file.sha256 || '';
            const shortHash = fullHash ? fullHash.slice(-4) : '—';
            const hashCell = fullHash
                ? `<span class="hash-short" title="${fullHash}">${shortHash}</span><button class="hash-copy-btn" onclick="event.stopPropagation(); copyHash('${fullHash}')" title="Copy full hash">⧉</button>`
                : `<span class="hash-short">—</span>`;

            return `
                <div class="file-row ${isSelected ? 'selected' : ''}"
                     onclick="selectFile('${filename.replace(/'/g, "\\'")}')">
                    <div class="category-indicator" style="background-color: ${categoryColor}"></div>
                    <span class="filename" title="${filename}">${filename}</span>
                    <div class="hash-cell">${hashCell}</div>
                </div>
            `;
        }

        function filterFiles() {
            // Note: File filtering is now handled by renderBinariesTable() in selectVersion()
        }

        function selectFileByName(filename) {
            selectFile(filename);

            // Also highlight in file list
            document.querySelectorAll('.file-row').forEach(el => {
                if (el.querySelector('.filename').textContent === filename) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }

        function selectFile(filename) {
            console.log('selectFile called with:', filename);
            console.log('selectedVersion:', selectedVersion);
            selectedFile = filename;

            // Update file list selection
            document.querySelectorAll('.file-row').forEach(el => {
                const elFilename = el.querySelector('.filename').textContent;
                el.classList.toggle('selected', elFilename === filename);
            });

            // Get file info from current version
            const fileInfo = null; // File info now comes from binaries API
            console.log('fileInfo:', fileInfo ? 'found' : 'null');

            // Get file history
            const baseName = filename.split(' (')[0];
            console.log('baseName:', baseName);
            const history = FILE_HISTORY_DATA[baseName];
            console.log('FILE_HISTORY_DATA keys:', Object.keys(FILE_HISTORY_DATA || {}).length);
            console.log('history:', history ? 'found' : 'null');

            console.log('Calling renderFileDetails...');
            renderFileDetails(filename, fileInfo, history);
            console.log('renderFileDetails returned');
        }

        function getFileType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            if (['dll', 'exe'].includes(ext)) return 'pe';
            if (['txt', 'ini', 'cfg', 'lng'].includes(ext)) return 'text';
            if (['html', 'htm'].includes(ext)) return 'html';
            if (['mpq'].includes(ext)) return 'mpq';
            return 'other';
        }

        function renderFileDetails(filename, fileInfo, history) {
            const container = document.getElementById('detailsContent');
            const fileType = getFileType(filename);
            const baseName = filename.split(' (')[0];

            console.log('renderFileDetails: fileType=', fileType, 'filename=', filename);

            // For PE files (DLL/EXE), always try to load from API even if fileInfo is null
            if (fileType === 'pe') {
                renderPEExportsView(container, baseName, filename, fileInfo, history);
                return;
            }

            // For other file types, require fileInfo or history
            if (!fileInfo && !history) {
                renderEmptyDetails();
                return;
            }

            // Render based on file type
            switch (fileType) {
                case 'mpq':
                    renderMPQPlaceholder(container, filename, fileInfo);
                    break;
                case 'text':
                    renderTextFileView(container, filename, fileInfo, history);
                    break;
                case 'html':
                case 'other':
                default:
                    renderGenericPlaceholder(container, filename, fileInfo, fileType);
                    break;
            }
        }

        function renderPEExportsView(container, baseName, filename, fileInfo, history) {
            // For PE files, always try to load function data from the API
            // baseName is the filename without path (e.g., "D2Client.dll")
            console.log('renderPEExportsView:', baseName);

            container.innerHTML = '<div style="padding:20px;color:#888;">Loading function data...</div>';

            loadFunctionData(baseName).then(funcData => {
                if (funcData && funcData.functions && Object.keys(funcData.functions).length > 0) {
                    console.log('Function data loaded:', baseName, 'count:', Object.keys(funcData.functions).length);
                    renderFunctionsTable(container, baseName, funcData, filename, fileInfo);
                } else {
                    // No function data from API, fall back to exports
                    console.log('No function data from API, falling back to exports');
                    renderExportsTable(container, baseName, filename, fileInfo);
                }
            }).catch(err => {
                console.error('Failed to load function data:', err);
                renderExportsTable(container, baseName, filename, fileInfo);
            });
        }

        function renderFunctionsTable(container, baseName, funcData, filename, fileInfo) {
            // Extract function data from API response
            const functions = funcData.functions || {};
            const versions = funcData.versions || [];
            const functionNames = Object.keys(functions).sort();

            console.log('renderFunctionsTable: rendering', functionNames.length, 'functions across', versions.length, 'versions');

            // Safely get the selected version
            const currentVersion = selectedVersion ? selectedVersion.split('/')[1] : '';

            // Build header row with version columns
            const versionHeaders = versions.map(version => {
                const shortVer = version.split('/')[1] || version;
                return `<th class="sortable" data-sort-column="${version}">${shortVer}<span class="sort-indicator">⇅</span></th>`;
            }).join('');

            // Build table body with function rows
            const functionRows = functionNames.map(funcName => {
                const func = functions[funcName];
                const category = func.category || 'Other';
                const addresses = func.addresses || {};

                const addressCells = versions.map(version => {
                    const addr = addresses[version.split('/')[1] || version];
                    return `<td class="addr-cell ${!addr ? 'missing' : ''}">${addr || '—'}</td>`;
                }).join('');

                return `<tr data-category="${category.toLowerCase()}">
                    <td class="fn-name-cell" title="${funcName}">${funcName}</td>
                    ${addressCells}
                </tr>`;
            }).join('');

            const html = `
                <div class="exports-container">
                    <div class="exports-header">
                        <div class="exports-header-title">${baseName} - Functions [${currentVersion}]</div>
                        <div class="exports-header-info">${functionNames.length} functions in this version</div>
                    </div>
                    <div class="exports-controls">
                        <input type="text" placeholder="Search name or address..." id="functionsSearch" class="search-input" />
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-view="named">Named</button>
                            <button class="filter-btn" data-view="rva">RVA</button>
                            <button class="filter-btn" data-view="gaps">Gaps</button>
                            <button class="filter-btn" data-view="copy">Copy</button>
                            <button class="filter-btn" data-view="sig">Sig</button>
                        </div>
                        <select id="categoryFilter" class="category-filter" title="Filter by function category">
                            <option value="all">All</option>
                            <option value="Game">Game</option>
                            <option value="CRT">CRT</option>
                            <option value="Import">Import</option>
                            <option value="EH">EH</option>
                            <option value="Other">Other</option>
                        </select>
                        <div class="function-count">${functionNames.length}/${functionNames.length} (${functionNames.length})</div>
                        <div class="legend">
                            <span class="legend-item game">Game</span>
                            <span class="legend-item crt">CRT</span>
                            <span class="legend-item imp">IMP</span>
                            <span class="legend-item eh">EH</span>
                        </div>
                    </div>
                    <div class="exports-table-wrapper" id="functionsTableWrapper">
                        <table class="exports-table" id="functionsTable">
                            <thead>
                                <tr>
                                    <th class="fn-name-cell sortable sort-asc" data-sort-column="function">Function<span class="sort-indicator">▲</span></th>
                                    ${versionHeaders}
                                </tr>
                            </thead>
                            <tbody id="functionsTableBody">
                                ${functionRows}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function renderExportsTable(container, baseName, filename, fileInfo) {
            const exportsData = typeof EXPORTS_DATA !== 'undefined' ? EXPORTS_DATA[baseName] : null;

            if (!exportsData || Object.keys(exportsData.exports).length === 0) {
                // No exports, show basic info
                renderGenericPlaceholder(container, filename, fileInfo, 'pe-no-exports');
                return;
            }

            // Get variant count from FILE_HISTORY_DATA for consistency with center panel
            const history = FILE_HISTORY_DATA[baseName];
            const variantCount = history?.variant_count || 1;

            // Get sorted ordinals
            const ordinals = Object.keys(exportsData.exports).sort((a, b) => parseInt(a) - parseInt(b));
            const allVersions = exportsData.versions;

            // Group versions by file hash variants from FILE_HISTORY_DATA
            // This ensures column groupings match the variant count shown in the header
            const versionGroups = [];

            if (history && history.variants) {
                // Use the pre-computed variant groupings from FILE_HISTORY_DATA
                for (const variant of history.variants) {
                    // Filter to only versions that have export data
                    const versionsWithExports = variant.versions.filter(v => allVersions.includes(v));
                    if (versionsWithExports.length > 0) {
                        const startVer = versionsWithExports[0].split('/')[1] || versionsWithExports[0];
                        const endVer = versionsWithExports[versionsWithExports.length - 1].split('/')[1] || versionsWithExports[versionsWithExports.length - 1];
                        versionGroups.push({
                            versions: versionsWithExports,
                            startVer: startVer,
                            endVer: endVer
                        });
                    }
                }
            } else {
                // Fallback: group all versions together if no history data
                if (allVersions.length > 0) {
                    const startVer = allVersions[0].split('/')[1] || allVersions[0];
                    const endVer = allVersions[allVersions.length - 1].split('/')[1] || allVersions[allVersions.length - 1];
                    versionGroups.push({
                        versions: allVersions,
                        startVer: startVer,
                        endVer: endVer
                    });
                }
            }

            // Find which group contains the selected version
            let selectedGroupIndex = -1;
            for (let i = 0; i < versionGroups.length; i++) {
                if (versionGroups[i].versions.includes(selectedVersion)) {
                    selectedGroupIndex = i;
                    break;
                }
            }

            let html = `
                <div class="exports-container">
                    <div class="exports-header">
                        <div class="exports-header-title">${baseName} - Export Table</div>
                        <div class="exports-header-info">${ordinals.length} exports across ${variantCount} variant${variantCount !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="exports-table-wrapper" id="exportsTableWrapper">
                        <table class="exports-table" id="exportsTable">
                            <thead>
                                <tr>
                                    <th class="fn-name-cell sortable sort-asc" data-sort-column="function" onclick="handleExportsTableSort('function', this)">Function<span class="sort-indicator"></span></th>
                                    ${versionGroups.map((group, idx) => {
                const isSelected = idx === selectedGroupIndex;
                const label = group.startVer === group.endVer
                    ? group.startVer
                    : `${group.startVer} - ${group.endVer}`;
                const tooltip = group.versions.join(', ');
                return `<th class="sortable ${isSelected ? 'selected-version' : ''}" data-sort-column="${idx}" data-version="${group.versions[0]}" onclick="handleExportsTableSort(${idx}, this)" title="${tooltip}">${label}<span class="sort-indicator"></span></th>`;
            }).join('')}
                                </tr>
                            </thead>
                            <tbody id="exportsTableBody">
                                ${ordinals.map(ord => {
                const exp = exportsData.exports[ord];
                const displayName = exp.name || `#${exp.ordinal}`;

                // Build address cells for each group (use first version in group)
                let prevAddr = null;
                const addrCells = versionGroups.map(group => {
                    const addr = exp.addresses[group.versions[0]];
                    const isChanged = prevAddr !== null && addr !== prevAddr && addr;
                    const cellClass = !addr ? 'missing' : (isChanged ? 'changed' : '');
                    prevAddr = addr || prevAddr;
                    return `<td class="addr-cell ${cellClass}">${addr || '—'}</td>`;
                }).join('');

                return `
                                        <tr>
                                            <td class="fn-name-cell" title="${displayName}">${displayName}</td>
                                            ${addrCells}
                                        </tr>
                                    `;
            }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            container.innerHTML = html;

            // Scroll to selected version group column
            if (selectedGroupIndex > 0) {
                const wrapper = document.getElementById('exportsTableWrapper');
                const table = wrapper.querySelector('table');
                const headerCells = table.querySelectorAll('thead th');
                if (headerCells[selectedGroupIndex + 1]) {
                    // Calculate scroll position (account for sticky column)
                    const targetCell = headerCells[selectedGroupIndex + 1];
                    const stickyColWidth = headerCells[0].offsetWidth;
                    wrapper.scrollLeft = targetCell.offsetLeft - stickyColWidth - 10;
                }
            }
        }


        // Get tier title for tooltip
        function getTierTitle(tier) {
            const titles = {
                1: 'Tier 1: Export Name Match',
                2: 'Tier 2: Exact Bytes Match',
                3: 'Tier 3: Prologue + Size Match',
                4: 'Tier 4: Call Graph Match'
            };
            return titles[tier] || 'Unknown tier';
        }

        // Table sorting functions
        function handleTableSort(column) {
            // If clicking the same column, toggle direction; otherwise, set to ascending
            if (tableSortColumn === column) {
                tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                tableSortColumn = column;
                tableSortDirection = 'asc';
            }

            // Update header classes
            updateSortIndicators();

            // Re-render table body with new sort
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        function updateSortIndicators() {
            const headers = document.querySelectorAll('.exports-table thead th.sortable');
            headers.forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                const col = th.dataset.sortColumn;
                if (col === String(tableSortColumn)) {
                    th.classList.add(tableSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function sortFunctionKeys(funcKeys, funcData, versionGroups) {
            const sortedKeys = [...funcKeys];

            sortedKeys.sort((a, b) => {
                let comparison = 0;
                const funcA = funcData.functions[a];
                const funcB = funcData.functions[b];

                if (tableSortColumn === 'function') {
                    // Sort by function name
                    const nameA = (funcA.name || a).toLowerCase();
                    const nameB = (funcB.name || b).toLowerCase();
                    comparison = nameA.localeCompare(nameB);
                } else {
                    // Sort by address in the specified version group
                    const groupIdx = parseInt(tableSortColumn);
                    if (versionGroups[groupIdx]) {
                        const version = versionGroups[groupIdx].versions[0];
                        const addrA = getDisplayAddress(funcA, version) || '';
                        const addrB = getDisplayAddress(funcB, version) || '';

                        // Parse addresses for numeric comparison
                        const numA = addrA ? parseInt(addrA.replace('0x', ''), 16) : -1;
                        const numB = addrB ? parseInt(addrB.replace('0x', ''), 16) : -1;

                        // Sort empty addresses to the end
                        if (numA === -1 && numB === -1) comparison = 0;
                        else if (numA === -1) comparison = 1;
                        else if (numB === -1) comparison = -1;
                        else comparison = numA - numB;
                    }
                }

                return tableSortDirection === 'asc' ? comparison : -comparison;
            });

            return sortedKeys;
        }

        // Handle exports table sorting (in-place DOM sort for static table)
        function handleExportsTableSort(column, clickedTh) {
            const table = document.getElementById('exportsTable');
            if (!table) return;

            const tbody = document.getElementById('exportsTableBody');
            if (!tbody) return;

            // Determine sort direction
            const headers = table.querySelectorAll('thead th.sortable');
            let sortDirection = 'asc';

            headers.forEach(th => {
                if (th === clickedTh) {
                    if (th.classList.contains('sort-asc')) {
                        sortDirection = 'desc';
                        th.classList.remove('sort-asc');
                        th.classList.add('sort-desc');
                    } else if (th.classList.contains('sort-desc')) {
                        sortDirection = 'asc';
                        th.classList.remove('sort-desc');
                        th.classList.add('sort-asc');
                    } else {
                        sortDirection = 'asc';
                        th.classList.add('sort-asc');
                    }
                } else {
                    th.classList.remove('sort-asc', 'sort-desc');
                }
            });

            // Get all rows
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Sort rows
            rows.sort((rowA, rowB) => {
                let comparison = 0;

                if (column === 'function') {
                    // Sort by function name (first cell)
                    const nameA = rowA.cells[0].textContent.toLowerCase();
                    const nameB = rowB.cells[0].textContent.toLowerCase();
                    comparison = nameA.localeCompare(nameB);
                } else {
                    // Sort by address in the specified column
                    const colIdx = parseInt(column) + 1; // +1 for function column
                    const cellA = rowA.cells[colIdx];
                    const cellB = rowB.cells[colIdx];

                    const addrA = cellA ? cellA.textContent.trim() : '';
                    const addrB = cellB ? cellB.textContent.trim() : '';

                    // Parse addresses for numeric comparison
                    const numA = addrA && addrA !== '—' ? parseInt(addrA.replace('0x', ''), 16) : -1;
                    const numB = addrB && addrB !== '—' ? parseInt(addrB.replace('0x', ''), 16) : -1;

                    // Sort empty addresses to the end
                    if (numA === -1 && numB === -1) comparison = 0;
                    else if (numA === -1) comparison = 1;
                    else if (numB === -1) comparison = -1;
                    else comparison = numA - numB;
                }

                return sortDirection === 'asc' ? comparison : -comparison;
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // Check if a function has a "real" name (not auto-generated)
        function isNamedFunction(func, key) {
            const name = func.name || '';
            // Consider it "named" if it has a name that's not just the key itself
            // and doesn't look like a generic auto-generated name
            if (!name || name === key) return false;
            // Check for common auto-generated patterns
            if (name.startsWith('FUN_')) return false;
            if (name.startsWith('Ordinal_')) return false;
            if (name.match(/^sub_[0-9a-fA-F]+$/)) return false;
            return true;
        }

        // Get Ghidra-style CSS class for function name coloring
        function getGhidraNameClass(name, category) {
            if (!name) return 'ghidra-unnamed';
            // FUN_* = gray (auto-generated)
            if (name.startsWith('FUN_') || name.match(/^sub_[0-9a-fA-F]+$/)) {
                return 'ghidra-unnamed';
            }
            // Ordinal_* = goldenrod (thunk/ordinal)
            if (name.startsWith('Ordinal_')) {
                return 'ghidra-ordinal';
            }
            // Import category = blue
            if (category === 'import') {
                return 'ghidra-import';
            }
            // CRT/library = sky blue
            if (category === 'crt') {
                return 'ghidra-library';
            }
            // Exception handling = salmon
            if (category === 'exception') {
                return 'ghidra-exception';
            }
            // Thunk/wrapper patterns = red (external API wrappers, runtime thunks)
            if (isThunkFunction(name)) {
                return 'ghidra-thunk';
            }
            // Named functions = cyan (user-defined)
            return 'ghidra-named';
        }

        // Check if function name indicates a thunk/wrapper function
        function isThunkFunction(name) {
            // Wrapper suffixes
            if (name.endsWith('Wrapper') || name.endsWith('_Wrapper')) return true;
            // Windows API thunks
            if (name.startsWith('Rtl') || name.startsWith('Nt')) return true;
            // Critical section wrappers
            if (name.includes('CriticalSection')) return true;
            // Memory pool/allocation thunks
            if (name.match(/^(Alloc|Free|Deallocate).*Pool/)) return true;
            if (name.match(/Pool.*Tracked$/)) return true;
            // Cleanup/abort handlers
            if (name === 'CleanupAndAbort' || name === 'AbortAndCleanup') return true;
            // Resource allocation thunks
            if (name.match(/^(Allocate|Deallocate).*Resource/)) return true;
            // Process/interpret bytecode
            if (name.startsWith('Interpret') || name.startsWith('Process')) return true;
            return false;
        }

        // Handler for function search input
        function onFuncSearchInput(value) {
            funcSearchFilter = value.toLowerCase();
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Check if a string looks like an address (hex pattern)
        function isAddressSearch(searchTerm) {
            // Match patterns like: 0x6fb12345, 6fb12345, 0x1234, 12345 (4+ hex chars)
            return /^(0x)?[0-9a-f]{4,}$/i.test(searchTerm.trim());
        }

        // Check if function matches address search across all versions
        function matchesAddressSearch(func, searchTerm) {
            const normalizedSearch = searchTerm.replace(/^0x/i, '').toLowerCase();

            // Check confirmed addresses
            if (func.addresses) {
                for (const version in func.addresses) {
                    const addr = func.addresses[version];
                    if (addr && addr.toLowerCase().replace(/^0x/i, '').includes(normalizedSearch)) {
                        return true;
                    }
                }
            }

            // Check RVAs
            if (func.rvas) {
                for (const version in func.rvas) {
                    const rva = func.rvas[version];
                    if (rva && rva.toLowerCase().replace(/^0x/i, '').includes(normalizedSearch)) {
                        return true;
                    }
                }
            }

            // Check candidate addresses
            if (func.candidates) {
                for (const version in func.candidates) {
                    const candidate = func.candidates[version];
                    if (candidate && candidate.address &&
                        candidate.address.toLowerCase().replace(/^0x/i, '').includes(normalizedSearch)) {
                        return true;
                    }
                    if (candidate && candidate.rva &&
                        candidate.rva.toLowerCase().replace(/^0x/i, '').includes(normalizedSearch)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Handler for "Named Only" toggle
        function toggleNamedOnly() {
            showOnlyNamed = !showOnlyNamed;
            const btn = document.getElementById('namedOnlyToggle');
            if (btn) {
                btn.classList.toggle('active', showOnlyNamed);
            }
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Handler for category filter change
        function onCategoryFilterChange(value) {
            categoryFilter = value;
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Handler for "Show RVA" toggle
        function toggleRVA() {
            showRVA = !showRVA;
            const btn = document.getElementById('rvaToggle');
            if (btn) {
                btn.classList.toggle('active', showRVA);
            }
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Handler for "Gaps Only" toggle
        function toggleGapsOnly() {
            showGapsOnly = !showGapsOnly;
            const btn = document.getElementById('gapsOnlyToggle');
            if (btn) {
                btn.classList.toggle('active', showGapsOnly);
            }
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Handler for "Copy on Click" toggle
        function toggleCopyOnClick() {
            copyOnClick = !copyOnClick;
            const btn = document.getElementById('copyOnClickToggle');
            if (btn) {
                btn.classList.toggle('active', copyOnClick);
            }
        }

        // Handler for "Show Signatures" toggle
        function toggleSignatures() {
            showSignatures = !showSignatures;
            const btn = document.getElementById('signaturesToggle');
            if (btn) {
                btn.classList.toggle('active', showSignatures);
            }
            if (currentFuncData && currentFuncBaseName) {
                updateFunctionsTableBody();
            }
        }

        // Get the appropriate address based on RVA toggle
        function getDisplayAddress(func, version) {
            if (showRVA && func.rvas && func.rvas[version]) {
                return func.rvas[version];
            }
            return func.addresses ? func.addresses[version] : null;
        }

        // Update just the table body (for filtering without full re-render)
        function updateFunctionsTableBody() {
            const tbody = document.getElementById('funcTableBody');
            const statsEl = document.getElementById('funcFilterStats');
            if (!tbody || !currentFuncData) return;

            const funcData = currentFuncData;
            const history = FILE_HISTORY_DATA[currentFuncBaseName];

            // Use stored version groups, or rebuild if needed
            let versionGroups = currentVersionGroups;

            // Rebuild version groups if empty (safety fallback)
            if (!versionGroups || versionGroups.length === 0) {
                const allVersions = funcData.versions || [];
                versionGroups = [];

                // Check if using API format (flat array of version strings)
                if (allVersions.length > 0 && typeof allVersions[0] === 'string') {
                    // API format: each version gets its own column
                    for (const version of allVersions) {
                        versionGroups.push({
                            versions: [version],
                            startVer: version.split('/')[1] || version,
                            endVer: version.split('/')[1] || version
                        });
                    }
                } else if (history && history.variants) {
                    for (const variant of history.variants) {
                        const versionsWithFuncs = variant.versions.filter(v => {
                            if (!allVersions.includes(v)) return false;
                            return filterVersionsByType([v]).length > 0;
                        });
                        if (versionsWithFuncs.length > 0) {
                            versionGroups.push({ versions: versionsWithFuncs });
                        }
                    }
                } else if (allVersions.length > 0) {
                    const filteredVersions = filterVersionsByType(allVersions);
                    if (filteredVersions.length > 0) {
                        versionGroups.push({ versions: filteredVersions });
                    }
                }
                currentVersionGroups = versionGroups;
            }

            // Filter and sort function keys
            let funcKeys = Object.keys(funcData.functions);

            // Filter by selected version FIRST (if a version is selected)
            if (selectedVersion) {
                funcKeys = funcKeys.filter(key => {
                    const func = funcData.functions[key];
                    // Include ONLY if function has a confirmed address in selected version
                    return func.addresses && func.addresses[selectedVersion];
                });
            }

            let namedCount = 0;

            // Count named functions (from the version-filtered set)
            funcKeys.forEach(key => {
                if (isNamedFunction(funcData.functions[key], key)) namedCount++;
            });

            // Build duplicate set for this data
            const duplicates = findDuplicateFunctions(funcData);

            // Apply additional filters
            funcKeys = funcKeys.filter(key => {
                const func = funcData.functions[key];
                const name = func.name || key;

                // Named only filter
                if (showOnlyNamed && !isNamedFunction(func, key)) return false;

                // Search filter - check addresses if search looks like an address
                if (funcSearchFilter) {
                    if (isAddressSearch(funcSearchFilter)) {
                        // Address search - check all address columns
                        if (!matchesAddressSearch(func, funcSearchFilter)) return false;
                    } else {
                        // Name search - check function name
                        if (!name.toLowerCase().includes(funcSearchFilter)) return false;
                    }
                }

                // Category filter
                if (categoryFilter !== 'all') {
                    const category = getFunctionCategory(name);
                    if (category !== categoryFilter) return false;
                }

                // Gaps only filter - show functions that have gaps in version coverage
                if (showGapsOnly) {
                    const gapInfo = analyzeGapPattern(func, versionGroups);
                    if (!gapInfo) return false;  // Skip functions with no gap pattern (fully/mostly covered)
                }

                return true;
            });

            // Sort using current sort settings
            funcKeys = sortFunctionKeys(funcKeys, funcData, versionGroups);

            // Update stats with category info
            if (statsEl) {
                const totalCount = Object.keys(funcData.functions).length;
                const dupCount = duplicates.size;
                let statsHtml = `${funcKeys.length}/${totalCount} (<span class="named-count">${namedCount}</span>)`;
                if (dupCount > 0) {
                    statsHtml += ` <span style="color: var(--color-rare);">(${dupCount} dup)</span>`;
                }
                statsEl.innerHTML = statsHtml;
            }

            // Get all versions for gap analysis
            const allVersions = funcData.versions || [];

            // Render rows
            tbody.innerHTML = funcKeys.map(key => {
                const func = funcData.functions[key];
                const displayName = func.name || key;
                const isNamed = isNamedFunction(func, key);
                const nameClass = getGhidraNameClass(displayName, getFunctionCategory(displayName));
                const tier = func.tier || 0;
                const tierClass = tier > 0 ? 'tier-' + tier : '';
                const tierTitle = getTierTitle(tier);

                // Get function category
                const category = getFunctionCategory(displayName);
                const catInfo = getCategoryInfo(category);

                // Check for duplicates
                const isDuplicate = duplicates.has(key);

                // Analyze gap pattern
                const gapPattern = analyzeGapPattern(func, allVersions);

                // Use the currently selected version from version panel as source for comparisons
                // If selectedVersion has an address for this function, use it; otherwise fall back to first available
                let rowSourceVersion = null;
                if (selectedVersion && func.addresses && func.addresses[selectedVersion]) {
                    rowSourceVersion = selectedVersion;
                } else {
                    // Fall back: find first version with an address
                    for (const group of versionGroups) {
                        const ver = group.versions[0];
                        if (func.addresses && func.addresses[ver]) {
                            rowSourceVersion = ver;
                            break;
                        }
                    }
                }

                let prevAddr = null;
                let prevVersion = null;
                const addrCells = versionGroups.map((group, idx) => {
                    const version = group.versions[0];
                    const addr = getDisplayAddress(func, version);

                    // For source version tracking: use selected version or first confirmed
                    const cellSourceVersion = rowSourceVersion || version;

                    // Detect compiler boundary crossing
                    const isBoundary = prevVersion && !PRE_111_VERSIONS.includes(version) && PRE_111_VERSIONS.includes(prevVersion);
                    const boundaryClass = isBoundary ? ' compiler-boundary' : '';

                    // Check for candidate if no confirmed address
                    if (!addr && func.candidates && func.candidates[version]) {
                        const candidate = func.candidates[version];
                        const status = getMatchStatus(key, version, candidate.address);
                        const candAddr = showRVA && candidate.rva ? candidate.rva : candidate.address;
                        const confidence = candidate.confidence || 0;

                        let cellClass = 'addr-cell candidate' + boundaryClass;
                        if (status === 'confirmed') {
                            cellClass = 'addr-cell confirmed' + boundaryClass;
                        } else if (status === 'rejected') {
                            cellClass = 'addr-cell rejected' + boundaryClass;
                        } else if (confidence >= 0.8) {
                            cellClass += ' candidate-high';
                        } else if (confidence < 0.6) {
                            cellClass += ' candidate-low';
                        }

                        const confidenceTitle = `${status === 'confirmed' ? 'Confirmed' : status === 'rejected' ? 'Rejected' : 'Candidate'} (${(confidence * 100).toFixed(0)}% conf, ${candidate.method})`;

                        prevAddr = candAddr;
                        prevVersion = version;
                        // Use cellSourceVersion (based on selectedVersion) instead of candidate.source
                        return `<td class="${cellClass}" onclick="showComparePanel('${key}', '${version}', '${cellSourceVersion}', true)" title="${confidenceTitle}">${candAddr}</td>`;
                    }

                    const isChanged = prevAddr !== null && addr !== prevAddr && addr;
                    let cellClass = !addr ? 'missing' : (isChanged ? 'changed' : '');

                    // Add tier-based coloring for confirmed addresses
                    if (addr && tier > 0) {
                        cellClass += ' tier-' + tier + '-match';
                    }

                    cellClass += boundaryClass;
                    prevAddr = addr || prevAddr;
                    prevVersion = version;

                    if (addr) {
                        // Clickable confirmed address
                        const tierMatchTitle = tier > 0 ? tierTitle + ' - Click to compare' : 'Click to compare';
                        return `<td class="addr-cell ${cellClass}" onclick="showComparePanel('${key}', '${version}', '${cellSourceVersion}', false)" style="cursor:pointer" title="${tierMatchTitle}">${addr}</td>`;
                    }
                    return '<td class="addr-cell ' + cellClass + '">—</td>';
                }).join('');

                // Build name cell with category color bar, tier indicator, duplicate indicator, and gap indicator
                const categoryBar = `<div class="fn-category-bar ${catInfo.barClass}" title="${catInfo.title}"></div>`;
                const tierIndicator = tier > 0 ? '<span class="tier-indicator ' + tierClass + '" title="' + tierTitle + '">' + tier + '</span>' : '';
                const duplicateIndicator = isDuplicate ? `<span class="fn-duplicate-indicator" title="Duplicate function name">⚠</span>` : '';
                const gapIndicator = gapPattern ? `<span class="fn-gap-indicator gap-${gapPattern.type}" title="${gapPattern.title}"></span>` : '';

                // Signature display
                const signature = func.signature || '';
                const tooltipText = signature ? `${displayName}\n${signature}` : displayName;
                const signatureHtml = showSignatures && signature ? `<span class="fn-signature" title="${signature}">${signature}</span>` : '';
                const nameContent = showSignatures && signature
                    ? `<div class="fn-name-wrapper"><span class="fn-name-text">${displayName}</span>${signatureHtml}</div>`
                    : `<span class="fn-name-text">${displayName}</span>`;

                return '<tr><td class="fn-name-cell ' + nameClass + '" title="' + tooltipText.replace(/"/g, '&quot;') + '">' + categoryBar + tierIndicator + nameContent + duplicateIndicator + gapIndicator + '</td>' + addrCells + '</tr>';
            }).join('');
        }

        // Render function table (all detected functions, not just exports)
        function renderFunctionsTable(container, baseName, funcData, filename, fileInfo) {
            // Store for filtering
            currentFuncData = funcData;
            currentFuncBaseName = baseName;

            // Build rarity index for identity matching
            rarityIndex = buildRarityIndex(funcData);

            // Reset filters and sort when switching files
            funcSearchFilter = '';
            showOnlyNamed = false;
            tableSortColumn = 'function';
            tableSortDirection = 'asc';

            // Get variant count from FILE_HISTORY_DATA for consistency with center panel
            const history = FILE_HISTORY_DATA[baseName];
            const variantCount = history?.variant_count || 1;

            const allVersions = funcData.versions;

            // Filter functions to only those present in the selected version
            let funcKeys;
            if (selectedVersion) {
                // Extract just the version part from "Classic/1.00" -> "1.00"
                const versionKey = selectedVersion.split('/')[1] || selectedVersion;
                console.log('renderFunctionsTable: selectedVersion =', selectedVersion);
                console.log('renderFunctionsTable: versionKey =', versionKey);
                console.log('renderFunctionsTable: funcData.versions =', funcData.versions);
                console.log('renderFunctionsTable: sample function addresses =', Object.values(funcData.functions)[0]?.addresses);

                funcKeys = Object.keys(funcData.functions).filter(key => {
                    const func = funcData.functions[key];
                    // Include ONLY if function has a confirmed address in selected version
                    // (not just a candidate - candidates don't mean the function exists there)
                    return func.addresses && func.addresses[versionKey];
                });
                console.log('renderFunctionsTable: filtered funcKeys.length =', funcKeys.length);
            } else {
                // If no version selected, show all functions
                funcKeys = Object.keys(funcData.functions);
            }

            // Sort by function name alphabetically (case-insensitive)
            funcKeys.sort((a, b) => {
                const funcA = funcData.functions[a];
                const funcB = funcData.functions[b];
                const nameA = (funcA.name || a).toLowerCase();
                const nameB = (funcB.name || b).toLowerCase();
                return nameA.localeCompare(nameB);
            });

            // Count named functions
            let namedCount = 0;
            funcKeys.forEach(key => {
                if (isNamedFunction(funcData.functions[key], key)) namedCount++;
            });

            // Group versions by file hash variants from FILE_HISTORY_DATA
            // This ensures column groupings match the variant count shown in the header
            const versionGroups = [];

            // If using API data (funcData.versions is a flat array of version strings),
            // create one column per version (no grouping needed - API already deduplicates)
            if (allVersions && allVersions.length > 0 && typeof allVersions[0] === 'string') {
                // API format: each version gets its own column
                for (const version of allVersions) {
                    versionGroups.push({
                        versions: [version],
                        startVer: version.split('/')[1] || version,
                        endVer: version.split('/')[1] || version
                    });
                }
            } else if (history && history.variants) {
                // Legacy format: Use the pre-computed variant groupings from FILE_HISTORY_DATA
                for (const variant of history.variants) {
                    // Filter to only versions that have function data AND match Classic/LoD filter
                    const versionsWithFuncs = variant.versions.filter(v => {
                        if (!allVersions.includes(v)) return false;
                        // Apply Classic/LoD filter
                        return filterVersionsByType([v]).length > 0;
                    });
                    if (versionsWithFuncs.length > 0) {
                        const startVer = versionsWithFuncs[0].split('/')[1] || versionsWithFuncs[0];
                        const endVer = versionsWithFuncs[versionsWithFuncs.length - 1].split('/')[1] || versionsWithFuncs[versionsWithFuncs.length - 1];
                        versionGroups.push({
                            versions: versionsWithFuncs,
                            startVer: startVer,
                            endVer: endVer
                        });
                    }
                }
            } else {
                // Fallback: group all versions together if no history data
                const filteredVersions = filterVersionsByType(allVersions || []);
                if (filteredVersions.length > 0) {
                    const startVer = filteredVersions[0].split('/')[1] || filteredVersions[0];
                    const endVer = filteredVersions[filteredVersions.length - 1].split('/')[1] || filteredVersions[filteredVersions.length - 1];
                    versionGroups.push({
                        versions: filteredVersions,
                        startVer: startVer,
                        endVer: endVer
                    });
                }
            }

            // Store version groups globally for sorting
            currentVersionGroups = versionGroups;

            // Find which group contains the selected version
            let selectedGroupIndex = -1;
            for (let i = 0; i < versionGroups.length; i++) {
                if (versionGroups[i].versions.includes(selectedVersion)) {
                    selectedGroupIndex = i;
                    break;
                }
            }

            // Build filter indicator showing which version groups are active
            const allFiltersActive = Object.values(versionFilters).every(v => v);
            const activeNames = getActiveFilterNames();
            const filterIndicator = !allFiltersActive
                ? ` <span style="color: var(--accent-gold); font-size: 0.7rem;">[${activeNames.join('+')}]</span>`
                : '';

            // Build version indicator for header
            const versionIndicator = selectedVersion
                ? ` <span style="color: var(--accent-gold); font-size: 0.8rem;">[${selectedVersion.split('/')[1] || selectedVersion}]</span>`
                : '';

            let html = `
                <div class="exports-container">
                    <div class="exports-header">
                        <div class="exports-header-title">${baseName} - Functions${versionIndicator}${filterIndicator}</div>
                        <div class="exports-header-info">${funcKeys.length} function${funcKeys.length !== 1 ? 's' : ''}${selectedVersion ? ' in this version' : ' across ' + versionGroups.length + ' variant' + (versionGroups.length !== 1 ? 's' : '')}</div>
                    </div>
                    <div class="exports-toolbar">
                        <div class="exports-toolbar-row">
                            <input type="text" class="exports-search" id="funcSearchInput"
                                   placeholder="Search name or address..."
                                   oninput="onFuncSearchInput(this.value)">
                            <div class="exports-toolbar-separator"></div>
                            <button class="exports-toggle" id="namedOnlyToggle" onclick="toggleNamedOnly()" title="Show only named functions">
                                <span class="exports-toggle-indicator"></span>
                                <span>Named</span>
                            </button>
                            <button class="exports-toggle" id="rvaToggle" onclick="toggleRVA()" title="Show RVA instead of VA">
                                <span class="exports-toggle-indicator"></span>
                                <span>RVA</span>
                            </button>
                            <button class="exports-toggle" id="gapsOnlyToggle" onclick="toggleGapsOnly()" title="Show functions with version coverage gaps">
                                <span class="exports-toggle-indicator"></span>
                                <span>Gaps</span>
                            </button>
                            <button class="exports-toggle" id="copyOnClickToggle" onclick="toggleCopyOnClick()" title="Copy address to clipboard instead of compare">
                                <span class="exports-toggle-indicator"></span>
                                <span>Copy</span>
                            </button>
                            <button class="exports-toggle" id="signaturesToggle" onclick="toggleSignatures()" title="Show function signatures">
                                <span class="exports-toggle-indicator"></span>
                                <span>Sig</span>
                            </button>
                            <div class="exports-toolbar-separator"></div>
                            <select class="category-filter" id="categoryFilter" onchange="onCategoryFilterChange(this.value)" title="Filter by function category">
                                <option value="all">All</option>
                                <option value="game">Game</option>
                                <option value="crt">CRT</option>
                                <option value="import">Import</option>
                                <option value="exception">EH</option>
                                <option value="other">Other</option>
                            </select>
                            <span class="exports-stats" id="funcFilterStats">
                                ${funcKeys.length}/${funcKeys.length} (<span class="named-count">${namedCount}</span>)
                            </span>
                            <div class="category-legend">
                                <span class="category-legend-item" title="Game Logic"><span class="category-legend-bar cat-game"></span>Game</span>
                                <span class="category-legend-item" title="C Runtime"><span class="category-legend-bar cat-crt"></span>CRT</span>
                                <span class="category-legend-item" title="Import Thunk"><span class="category-legend-bar cat-import"></span>IMP</span>
                                <span class="category-legend-item" title="Exception Handling"><span class="category-legend-bar cat-exception"></span>EH</span>
                            </div>
                        </div>
                    </div>
                    <div class="exports-table-wrapper" id="exportsTableWrapper">
                        <table class="exports-table">
                            <thead>
                                <tr>
                                    <th class="fn-name-cell sortable ${tableSortColumn === 'function' ? (tableSortDirection === 'asc' ? 'sort-asc' : 'sort-desc') : ''}" data-sort-column="function" onclick="handleTableSort('function')">Function<span class="sort-indicator"></span></th>
                                    ${versionGroups.map((group, idx) => {
                const isSelected = idx === selectedGroupIndex;
                const isSorted = tableSortColumn === String(idx);
                const sortClass = isSorted ? (tableSortDirection === 'asc' ? 'sort-asc' : 'sort-desc') : '';
                const label = group.startVer === group.endVer
                    ? group.startVer
                    : group.startVer + ' - ' + group.endVer;
                const tooltip = group.versions.join(', ');
                return '<th class="sortable ' + (isSelected ? 'selected-version' : '') + ' ' + sortClass + '" data-sort-column="' + idx + '" onclick="handleTableSort(' + idx + ')" title="' + tooltip + '">' + label + '<span class="sort-indicator"></span></th>';
            }).join('')}
                                </tr>
                            </thead>
                            <tbody id="funcTableBody">
                                ${funcKeys.map(key => {
                const func = funcData.functions[key];
                const displayName = func.name || key;
                const isNamed = isNamedFunction(func, key);
                const nameClass = getGhidraNameClass(displayName, getFunctionCategory(displayName));
                const tier = func.tier || 0;
                const tierClass = tier > 0 ? 'tier-' + tier : '';
                const tierTitle = getTierTitle(tier);

                // Use the currently selected version from version panel as source for comparisons
                // If selectedVersion has an address for this function, use it; otherwise fall back to first available
                let rowSourceVersion = null;
                if (selectedVersion && func.addresses && func.addresses[selectedVersion]) {
                    rowSourceVersion = selectedVersion;
                } else {
                    // Fall back: find first version with an address
                    for (const group of versionGroups) {
                        const ver = group.versions[0];
                        if (func.addresses && func.addresses[ver]) {
                            rowSourceVersion = ver;
                            break;
                        }
                    }
                }

                let prevAddr = null;
                const addrCells = versionGroups.map((group, idx) => {
                    // Check all versions in the group to find if function exists in any of them
                    let version = group.versions[0];
                    let addr = getDisplayAddress(func, version);

                    // If not found in first version, check other versions in group
                    if (!addr && group.versions.length > 1) {
                        for (const v of group.versions) {
                            addr = getDisplayAddress(func, v);
                            if (addr) {
                                version = v;
                                break;
                            }
                        }
                    }

                    const cellSourceVersion = rowSourceVersion || version;

                    // Check for candidate if no confirmed address
                    if (!addr && func.candidates && func.candidates[version]) {
                        const candidate = func.candidates[version];
                        const status = getMatchStatus(key, version, candidate.address);
                        const candAddr = showRVA && candidate.rva ? candidate.rva : candidate.address;
                        const confidence = candidate.confidence || 0;

                        let cellClass = 'addr-cell candidate';
                        if (status === 'confirmed') {
                            cellClass = 'addr-cell confirmed';
                        } else if (status === 'rejected') {
                            cellClass = 'addr-cell rejected';
                        } else if (confidence >= 0.8) {
                            cellClass += ' candidate-high';
                        } else if (confidence < 0.6) {
                            cellClass += ' candidate-low';
                        }

                        const confidenceTitle = status === 'confirmed' ? 'Confirmed' : status === 'rejected' ? 'Rejected' : 'Candidate (' + (confidence * 100).toFixed(0) + '% conf, ' + candidate.method + ')';

                        prevAddr = candAddr;
                        // Use cellSourceVersion (based on selectedVersion) instead of candidate.source
                        return '<td class="' + cellClass + '" onclick="showComparePanel(\'' + key + '\', \'' + version + '\', \'' + cellSourceVersion + '\', true)" title="' + confidenceTitle + '">' + candAddr + '</td>';
                    }

                    const isChanged = prevAddr !== null && addr !== prevAddr && addr;
                    let cellClass = !addr ? 'missing' : (isChanged ? 'changed' : '');

                    // Add BSim similarity-based color coding
                    if (selectedVersion && addr) {
                        if (version === selectedVersion) {
                            // Selected version column: baseline - always blue
                            cellClass += ' exact-match';
                        } else {
                            // Other versions: color based on BSim similarity score
                            const similarity = func.similarities && func.similarities[version];
                            if (similarity !== undefined) {
                                cellClass += ' ' + getSimilarityColorClass(similarity);
                            } else {
                                // Fallback to original logic if no similarity data
                                const selectedVersionKey = selectedVersion.split('/')[1] || selectedVersion;
                                if (func.addresses && func.addresses[selectedVersionKey]) {
                                    cellClass += ' exact-match';
                                }
                            }
                        }
                    }

                    prevAddr = addr || prevAddr;

                    if (addr) {
                        // Generate tooltip with similarity information
                        const similarity = func.similarities && func.similarities[version];
                        let tooltip = 'Click to compare';
                        if (similarity !== undefined) {
                            tooltip = `BSim Similarity: ${(similarity * 100).toFixed(1)}% | ${tooltip}`;
                        }

                        return '<td class="addr-cell ' + cellClass + '" onclick="showComparePanel(\'' + key + '\', \'' + version + '\', \'' + cellSourceVersion + '\', false)" style="cursor:pointer" title="' + tooltip + '">' + addr + '</td>';
                    }
                    return '<td class="addr-cell ' + cellClass + '">—</td>';
                }).join('');

                const tierIndicator = tier > 0 ? '<span class="tier-indicator ' + tierClass + '" title="' + tierTitle + '">' + tier + '</span>' : '';

                // Signature display
                const signature = func.signature || '';
                const tooltipText = signature ? `${displayName}\n${signature}` : displayName;
                const signatureHtml = showSignatures && signature ? `<span class="fn-signature" title="${signature}">${signature}</span>` : '';
                const nameContent = showSignatures && signature
                    ? `<div class="fn-name-wrapper"><span class="fn-name-text">${displayName}</span>${signatureHtml}</div>`
                    : `<span class="fn-name-text">${displayName}</span>`;

                return '<tr><td class="fn-name-cell ' + nameClass + '" title="' + tooltipText.replace(/"/g, '&quot;') + '">' + tierIndicator + nameContent + '</td>' + addrCells + '</tr>';
            }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            container.innerHTML = html;

            // Scroll to selected version group column
            if (selectedGroupIndex > 0) {
                const wrapper = document.getElementById('exportsTableWrapper');
                const table = wrapper.querySelector('table');
                const headerCells = table.querySelectorAll('thead th');
                if (headerCells[selectedGroupIndex + 1]) {
                    const targetCell = headerCells[selectedGroupIndex + 1];
                    const stickyColWidth = headerCells[0].offsetWidth;
                    wrapper.scrollLeft = targetCell.offsetLeft - stickyColWidth - 10;
                }
            }
        }

        function renderMPQPlaceholder(container, filename, fileInfo) {
            container.innerHTML = `
                <div class="mpq-placeholder">
                    <div class="mpq-placeholder-icon">📦</div>
                    <div class="mpq-placeholder-text">
                        <strong>${filename}</strong><br><br>
                        MPQ Archive<br>
                        ${fileInfo?.size_readable || 'Unknown size'}<br><br>
                        <em>MPQ viewer coming soon</em>
                    </div>
                </div>
            `;
        }

        function renderTextFileView(container, filename, fileInfo, history) {
            const baseName = filename.split(' (')[0];
            const category = fileInfo?.category || 'Other';
            const categoryColor = fileInfo?.category_color || '#FFFFFF';

            // Check if we have text content data
            const textData = typeof TEXT_CONTENT_DATA !== 'undefined' ? TEXT_CONTENT_DATA : {};
            const fileTextData = textData[baseName];

            if (!fileTextData) {
                // No text content available - show placeholder
                container.innerHTML = `
                    <div class="mpq-placeholder">
                        <div class="mpq-placeholder-icon">📄</div>
                        <div class="mpq-placeholder-text">
                            <strong>${filename}</strong><br><br>
                            ${fileInfo?.size_readable || 'Unknown size'}<br><br>
                            <em>Text content not available in viewer data</em>
                        </div>
                    </div>
                `;
                return;
            }

            // Get content for selected version
            let content = null;
            let contentVersion = null;

            // First try exact match for selected version
            if (selectedVersion && fileTextData.versions) {
                const versionData = fileTextData.versions[selectedVersion];
                if (versionData) {
                    content = versionData.content;
                    contentVersion = selectedVersion;
                }
            }

            // If no exact match, find by hash
            if (!content && fileInfo?.sha256 && fileTextData.by_hash) {
                const hashContent = fileTextData.by_hash[fileInfo.sha256];
                if (hashContent) {
                    content = hashContent.content;
                    contentVersion = hashContent.first_version || 'unknown';
                }
            }

            // Fallback to first available version
            if (!content && fileTextData.versions) {
                const firstVersion = Object.keys(fileTextData.versions)[0];
                if (firstVersion) {
                    content = fileTextData.versions[firstVersion].content;
                    contentVersion = firstVersion;
                }
            }

            if (!content) {
                container.innerHTML = `
                    <div class="mpq-placeholder">
                        <div class="mpq-placeholder-icon">📄</div>
                        <div class="mpq-placeholder-text">
                            <strong>${filename}</strong><br><br>
                            <em>No content found for this version</em>
                        </div>
                    </div>
                `;
                return;
            }

            // Get variant count from FILE_HISTORY_DATA for consistency with center panel
            const variantCount = history?.variant_count || 1;

            // Render text content with header
            container.innerHTML = `
                <div class="text-view-container">
                    <div class="text-view-header">
                        <div class="text-view-title">
                            <span class="text-view-filename">${filename}</span>
                            <span class="text-view-badge" style="background-color: ${categoryColor}20; color: ${categoryColor}">${category}</span>
                        </div>
                        <div class="text-view-meta">
                            <span>${fileInfo?.size_readable || 'Unknown size'}</span>
                            <span class="text-view-separator">•</span>
                            <span>${variantCount} variant${variantCount !== 1 ? 's' : ''}</span>
                            <span class="text-view-separator">•</span>
                            <span>Showing: ${contentVersion.split('/').pop()}</span>
                        </div>
                    </div>
                    <div class="text-view-content">${escapeHtml(content)}</div>
                </div>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy text to clipboard and show feedback
        function copyToClipboard(text, element) {
            if (!text || text === '—') return;

            navigator.clipboard.writeText(text).then(() => {
                // Show visual feedback
                if (element) {
                    element.classList.add('copied');
                    setTimeout(() => element.classList.remove('copied'), 1000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        function renderGenericPlaceholder(container, filename, fileInfo, fileType) {
            const icons = {
                'pe-no-exports': '⚙️',
                'text': '📄',
                'html': '🌐',
                'other': '📁'
            };
            const descriptions = {
                'pe-no-exports': 'This PE file has no exported functions',
                'text': 'Text file viewer coming soon',
                'html': 'HTML file viewer coming soon',
                'other': 'Preview not available for this file type'
            };

            container.innerHTML = `
                <div class="mpq-placeholder">
                    <div class="mpq-placeholder-icon">${icons[fileType] || '📁'}</div>
                    <div class="mpq-placeholder-text">
                        <strong>${filename}</strong><br><br>
                        ${fileInfo?.size_readable || 'Unknown size'}<br><br>
                        <em>${descriptions[fileType] || 'Preview not available'}</em>
                    </div>
                </div>
            `;
        }

        function renderEmptyDetails() {
            document.getElementById('detailsContent').innerHTML = `
                <div class="details-empty">
                    <div class="details-empty-icon">🔍</div>
                    <div class="details-empty-text">
                        Select a file to view its evolution across versions<br><br>
                        Or search for a hash above to identify a file
                    </div>
                </div>
            `;
        }

        function getCategoryColor(category) {
            const colors = {
                'Game Logic': '#00FF00',
                'Graphics': '#6969FF',
                'Audio': '#A59263',
                'Network': '#FF6600',
                'Launcher': '#FFFF00',
                'MPQ': '#C7B377',
                'Utility': '#808080',
                'Other': '#FFFFFF'
            };
            return colors[category] || '#FFFFFF';
        }

        // Get CSS class based on BSim similarity score
        function getSimilarityColorClass(similarity) {
            if (similarity >= 0.95) return 'similarity-identical';   // #0066ff - Blue (very high similarity)
            if (similarity >= 0.85) return 'similarity-high';        // #0099cc - Light Blue (high similarity)
            if (similarity >= 0.75) return 'similarity-good';        // #00cc66 - Green (good similarity)
            if (similarity >= 0.65) return 'similarity-medium';      // #99cc00 - Yellow-Green (medium similarity)
            if (similarity >= 0.50) return 'similarity-low';         // #cc9900 - Orange (low similarity)
            return 'similarity-very-low';                           // #cc6600 - Red-Orange (very low similarity)
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const sign = bytes < 0 ? '-' : '';
            bytes = Math.abs(bytes);
            if (bytes < 1024) return `${sign}${bytes} B`;
            if (bytes < 1024 * 1024) return `${sign}${(bytes / 1024).toFixed(1)} KB`;
            return `${sign}${(bytes / (1024 * 1024)).toFixed(2)} MB`;
        }

        function copyHash(hash) {
            navigator.clipboard.writeText(hash);
            showToast('Hash copied to clipboard');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        async function searchByHash() {
            const searchHash = document.getElementById('hashSearch').value.trim().toLowerCase();
            console.log('searchByHash called with:', searchHash);
            console.log('VERSIONS_DATA available:', !!VERSIONS_DATA, 'length:', VERSIONS_DATA?.length);
            console.log('API_BASE_URL:', API_BASE_URL);

            if (!searchHash || searchHash.length < 4) {
                showToast('Enter at least 4 characters');
                return;
            }

            // Search through all versions using binaries API
            let found = false;

            for (const version of VERSIONS_DATA) {
                try {
                    const folderName = version.folder_name || `${version.game_type}/${version.version}`;
                    const [gameType, versionNum] = folderName.split('/');
                    console.log(`Searching version: ${folderName} (${gameType}/${versionNum})`);

                    // Fetch binaries for this version
                    const response = await fetch(`${API_BASE_URL}/binaries?gameType=${gameType}&version=${versionNum}`);
                    if (!response.ok) {
                        console.log(`Failed to fetch binaries for ${folderName}: ${response.status}`);
                        continue;
                    }

                    const binaries = await response.json();
                    console.log(`Got ${binaries.length} binaries for ${folderName}`);

                    // Search through binaries for matching hash (SHA256 or MD5)
                    for (const binary of binaries) {
                        const sha256Match = binary.sha256 && binary.sha256.toLowerCase().includes(searchHash);
                        const md5Match = binary.md5 && binary.md5.toLowerCase().includes(searchHash);
                        if (sha256Match || md5Match) {
                            const hashUsed = sha256Match ? binary.sha256 : binary.md5;
                            console.log(`Found match: ${binary.fileName} with hash ${hashUsed}`);
                            // Found it - select the version and file
                            selectVersion(folderName);
                            setTimeout(() => {
                                selectFile(binary.fileName);
                                showToast(`Found ${binary.fileName} in ${folderName}`);
                            }, 100);
                            found = true;
                            return;
                        }
                    }
                } catch (error) {
                    console.warn(`Error searching ${version.folder_name}:`, error);
                    continue;
                }
            }

            if (!found) {
                showToast('Hash not found');
            }
        }

        // ===========================================
        // Candidate Matching & Comparison System
        // ===========================================

        // LocalStorage keys
        const CONFIRMED_MATCHES_KEY = 'D2VersionChanger_confirmedMatches';
        const REJECTED_MATCHES_KEY = 'D2VersionChanger_rejectedMatches';

        // Load confirmed/rejected matches from localStorage
        function loadMatchDecisions() {
            try {
                const confirmed = localStorage.getItem(CONFIRMED_MATCHES_KEY);
                const rejected = localStorage.getItem(REJECTED_MATCHES_KEY);
                return {
                    confirmed: confirmed ? JSON.parse(confirmed) : {},
                    rejected: rejected ? JSON.parse(rejected) : {}
                };
            } catch (e) {
                console.error('Error loading match decisions:', e);
                return { confirmed: {}, rejected: {} };
            }
        }

        // Save match decision
        function saveMatchDecision(canonicalId, version, address, isConfirmed) {
            const decisions = loadMatchDecisions();
            const key = `${canonicalId}:${version}`;

            if (isConfirmed) {
                decisions.confirmed[key] = { address, timestamp: Date.now() };
                delete decisions.rejected[key];
            } else {
                decisions.rejected[key] = decisions.rejected[key] || [];
                decisions.rejected[key].push({ address, timestamp: Date.now() });
                delete decisions.confirmed[key];
            }

            localStorage.setItem(CONFIRMED_MATCHES_KEY, JSON.stringify(decisions.confirmed));
            localStorage.setItem(REJECTED_MATCHES_KEY, JSON.stringify(decisions.rejected));
        }

        // Get match status for a candidate
        function getMatchStatus(canonicalId, version, address) {
            const decisions = loadMatchDecisions();
            const key = `${canonicalId}:${version}`;

            if (decisions.confirmed[key] && decisions.confirmed[key].address === address) {
                return 'confirmed';
            }

            const rejectedList = decisions.rejected[key] || [];
            if (rejectedList.some(r => r.address === address)) {
                return 'rejected';
            }

            return 'pending';
        }

        // Current comparison state
        let currentComparisonData = null;

        // Helper: Calculate size similarity (0-100%)
        function calculateSizeSimilarity(size1, size2) {
            if (!size1 || !size2) return 0;
            const diff = Math.abs(size1 - size2);
            const avg = (size1 + size2) / 2;
            if (avg === 0) return 100;
            const similarity = Math.max(0, 100 - (diff / avg * 100));
            return Math.round(similarity);
        }

        // Helper: Find function data by address in a specific version
        function findFunctionByAddress(address, version) {
            if (!currentFuncData?.functions || !address) return null;
            const normalizedAddr = address.toLowerCase();
            for (const [canonicalId, func] of Object.entries(currentFuncData.functions)) {
                const funcAddr = func.addresses?.[version];
                if (funcAddr && funcAddr.toLowerCase() === normalizedAddr) {
                    return { canonicalId, func };
                }
            }
            return null;
        }

        // Helper: Calculate call graph similarity (based on shared callees)
        function calculateCallSimilarity(callees1, callees2) {
            if (!callees1?.length || !callees2?.length) return 0;
            const set1 = new Set(callees1.map(c => c.name || c));
            const set2 = new Set(callees2.map(c => c.name || c));
            const intersection = [...set1].filter(x => set2.has(x));
            const union = new Set([...set1, ...set2]);
            if (union.size === 0) return 100;
            return Math.round((intersection.length / union.size) * 100);
        }

        // Helper: Check if indexes match
        function checkIndexMatch(indexes1, indexes2) {
            if (!indexes1 || !indexes2) return { match: false, methods: [] };
            const matchedMethods = [];
            for (const method of ['API', 'EXP', 'STR', 'MNE', 'CFG', 'PRO']) {
                if (indexes1[method] && indexes2[method] && indexes1[method] === indexes2[method]) {
                    matchedMethods.push(method);
                }
            }
            return { match: matchedMethods.length > 0, methods: matchedMethods };
        }

        // Helper: Parse index string to object
        // Handles both "METHOD:hash" string format and {METHOD: hash} object format
        function parseIndexToObject(indexData) {
            if (!indexData) return {};
            if (typeof indexData === 'object') return indexData;
            if (typeof indexData === 'string') {
                // Parse "METHOD:hash" format
                const colonIdx = indexData.indexOf(':');
                if (colonIdx > 0) {
                    const method = indexData.substring(0, colonIdx).toUpperCase();
                    const hash = indexData.substring(colonIdx + 1);
                    return { [method]: hash };
                }
            }
            return {};
        }

        // Helper: Calculate constant similarity (Jaccard index)
        // Constants can be in "address||value" format - extract value for comparison
        function calculateConstantSimilarity(constants1, constants2) {
            if (!constants1?.length || !constants2?.length) return 0;
            const set1 = new Set(constants1.map(extractConstantValue));
            const set2 = new Set(constants2.map(extractConstantValue));
            const intersection = [...set1].filter(x => set2.has(x));
            const union = new Set([...set1, ...set2]);
            if (union.size === 0) return 100;
            return Math.round((intersection.length / union.size) * 100);
        }

        // ========== COUNT-BASED VECTOR MATCHING ==========
        // Feature weights and tolerances for count-based similarity
        // Higher weight = more reliable for matching
        const COUNT_FEATURES = {
            // All features require exact match except size (allows 15% variance)
            instruction_count: { weight: 0.15, tolerance: 0.0 },
            size: { weight: 0.15, tolerance: 0.15 },  // Only feature with tolerance
            api_count: { weight: 0.12, tolerance: 0.0 },
            param_count: { weight: 0.10, tolerance: 0.0 },
            callee_count: { weight: 0.08, tolerance: 0.0 },
            string_count: { weight: 0.07, tolerance: 0.0 },
            global_count: { weight: 0.06, tolerance: 0.0 },
            loop_count: { weight: 0.05, tolerance: 0.0 },
            constant_count: { weight: 0.04, tolerance: 0.0 },
            local_var_count: { weight: 0.03, tolerance: 0.0 },
            caller_count: { weight: 0.02, tolerance: 0.0 },
            stack_frame_size: { weight: 0.01, tolerance: 0.0 }
        };

        // Normalize weights to sum to 1.0
        const totalWeight = Object.values(COUNT_FEATURES).reduce((sum, f) => sum + f.weight, 0);
        for (const feat of Object.keys(COUNT_FEATURES)) {
            COUNT_FEATURES[feat].weight /= totalWeight;
        }

        // Helper: Compute similarity between two count values
        function computeFeatureSimilarity(val1, val2, tolerance) {
            if (val1 === 0 && val2 === 0) return 1.0;  // Both zero = perfect match
            if (val1 === 0 || val2 === 0) return 0.0;  // One zero = no match

            const ratio = Math.min(val1, val2) / Math.max(val1, val2);

            // Zero tolerance = must match exactly
            if (tolerance <= 0) {
                return val1 === val2 ? 1.0 : ratio;
            }

            // Within tolerance = high score, outside = exponential decay
            if (ratio >= (1.0 - tolerance)) {
                return 0.5 + 0.5 * (ratio - (1.0 - tolerance)) / tolerance;
            } else {
                return 0.5 * ratio / (1.0 - tolerance);
            }
        }

        // Helper: Extract count vector from function data for a specific version
        function extractCountVector(funcData, version) {
            const vector = {};

            // Get counts from per-version data if available
            const getVersionedCount = (field, fallback) => {
                const perVersion = funcData[field + 's'] || funcData[field + '_counts'];
                if (perVersion && perVersion[version] !== undefined) return perVersion[version];
                return fallback;
            };

            // Size
            const sizes = funcData.sizes || {};
            if (sizes[version] !== undefined) vector.size = sizes[version];

            // Instruction count
            const instrCounts = funcData.instruction_counts || {};
            if (instrCounts[version] !== undefined) vector.instruction_count = instrCounts[version];

            // Loop count
            const loopCounts = funcData.loop_counts || {};
            if (loopCounts[version] !== undefined) vector.loop_count = loopCounts[version];

            // Stack frame size
            const stackSizes = funcData.stack_frame_sizes || {};
            if (stackSizes[version] !== undefined) vector.stack_frame_size = stackSizes[version];

            // Callee count (from per-version count field, or array length)
            const calleeCounts = funcData.callee_counts || {};
            if (calleeCounts[version] !== undefined) {
                vector.callee_count = calleeCounts[version];
            } else if (funcData.callees?.[version]) {
                vector.callee_count = funcData.callees[version].length;
            }

            // Caller count
            const callerCounts = funcData.caller_counts || {};
            if (callerCounts[version] !== undefined) {
                vector.caller_count = callerCounts[version];
            } else if (funcData.callers?.[version]) {
                vector.caller_count = funcData.callers[version].length;
            }

            // String count
            const stringCounts = funcData.string_counts || {};
            if (stringCounts[version] !== undefined) {
                vector.string_count = stringCounts[version];
            } else if (funcData.strings?.[version]) {
                vector.string_count = funcData.strings[version].length;
            }

            // Constant count
            const constCounts = funcData.constant_counts || {};
            if (constCounts[version] !== undefined) {
                vector.constant_count = constCounts[version];
            } else if (funcData.constants?.[version]) {
                vector.constant_count = funcData.constants[version].length;
            }

            // Global count
            const globalCounts = funcData.global_counts || {};
            if (globalCounts[version] !== undefined) {
                vector.global_count = globalCounts[version];
            } else if (funcData.globals?.[version]) {
                vector.global_count = funcData.globals[version].length;
            }

            // API count
            const apiCounts = funcData.api_counts || {};
            if (apiCounts[version] !== undefined) {
                vector.api_count = apiCounts[version];
            } else if (funcData.api_calls?.[version]) {
                vector.api_count = funcData.api_calls[version].length;
            }

            // Param count
            const paramCounts = funcData.param_counts || {};
            if (paramCounts[version] !== undefined) vector.param_count = paramCounts[version];

            return vector;
        }

        // Compute count-based vector similarity between two functions
        // Returns { score: 0-100, breakdown: {feature: {val1, val2, sim, weight, contrib}}, featureCount }
        function computeCountVectorSimilarity(sourceData, targetData, sourceVersion, targetVersion) {
            const vec1 = extractCountVector(sourceData, sourceVersion);
            const vec2 = extractCountVector(targetData, targetVersion);

            // Find common features with values
            const commonFeatures = Object.keys(COUNT_FEATURES).filter(
                f => vec1[f] !== undefined && vec2[f] !== undefined
            );

            if (commonFeatures.length < 3) {
                return { score: 0, breakdown: {}, featureCount: commonFeatures.length, error: 'insufficient_features' };
            }

            let totalWeight = 0;
            let weightedSum = 0;
            const breakdown = {};

            for (const feature of commonFeatures) {
                const val1 = vec1[feature];
                const val2 = vec2[feature];
                const { weight, tolerance } = COUNT_FEATURES[feature];

                const sim = computeFeatureSimilarity(val1, val2, tolerance);
                weightedSum += sim * weight;
                totalWeight += weight;

                breakdown[feature] = {
                    val1, val2,
                    similarity: Math.round(sim * 100),
                    weight: Math.round(weight * 100),
                    contribution: Math.round(sim * weight * 100)
                };
            }

            const score = totalWeight > 0 ? Math.round((weightedSum / totalWeight) * 100) : 0;

            return { score, breakdown, featureCount: commonFeatures.length };
        }

        // Helper: Calculate global reference similarity
        // Globals are "address|name|value" strings - compare by name if available, else value
        function calculateGlobalSimilarity(globals1, globals2) {
            if (!globals1?.length || !globals2?.length) return 0;
            const getIdentifier = g => {
                if (typeof g === 'string') {
                    const parts = g.split('|');
                    // Format: address|name|value - prefer name, fall back to value
                    if (parts.length >= 3) return parts[1] || parts[2] || parts[0];
                    if (parts.length === 2) return parts[1] || parts[0];
                    return parts[0];
                }
                return g.name || g.rva || String(g);
            };
            const set1 = new Set(globals1.map(getIdentifier));
            const set2 = new Set(globals2.map(getIdentifier));
            const intersection = [...set1].filter(x => set2.has(x));
            const union = new Set([...set1, ...set2]);
            if (union.size === 0) return 100;
            return Math.round((intersection.length / union.size) * 100);
        }

        // Build a map of version -> Set of used addresses
        // This is used to prevent showing candidates that are already matched elsewhere
        function buildUsedAddressesMap(funcData, versions) {
            const usedMap = {};
            for (const ver of versions) {
                usedMap[ver] = new Set();
            }

            for (const key in funcData.functions) {
                const func = funcData.functions[key];
                const addresses = func.addresses || {};
                for (const ver in addresses) {
                    if (usedMap[ver] && addresses[ver]) {
                        usedMap[ver].add(addresses[ver]);
                    }
                }
            }
            return usedMap;
        }

        // Find the best dynamic candidate for an empty cell using vector similarity
        // Returns { address, rva, confidence, method, isUsedElsewhere } or null if no good match found
        function findBestDynamicCandidate(sourceFunc, targetVersion, sourceVersion, funcData, usedAddresses, showRVA) {
            // We need to find a function in targetVersion that best matches sourceFunc

            // Skip if source function has no data for source version
            if (!sourceFunc.addresses || !sourceFunc.addresses[sourceVersion]) {
                return null;
            }

            const usedSet = usedAddresses[targetVersion] || new Set();
            let bestCandidate = null;
            let bestScore = 0;
            const minScore = 50; // Minimum 50% similarity to show

            // Look for functions that have an address in target version
            for (const key in funcData.functions) {
                const targetFunc = funcData.functions[key];
                const targetAddr = targetFunc.addresses?.[targetVersion];

                // Skip if no address in target version
                if (!targetAddr) continue;

                // Compute vector similarity
                const simResult = computeCountVectorSimilarity(sourceFunc, targetFunc, sourceVersion, targetVersion);

                if (simResult.score >= minScore && simResult.score > bestScore) {
                    bestScore = simResult.score;
                    bestCandidate = {
                        address: targetAddr,
                        rva: targetFunc.rvas?.[targetVersion] || targetAddr,
                        confidence: simResult.score / 100,
                        method: 'vector',
                        matchedKey: key,
                        matchedName: targetFunc.name || key,
                        isUsedElsewhere: usedSet.has(targetAddr)
                    };
                }
            }

            return bestCandidate;
        }

        // Helper: Render indexes side-by-side table
        function renderIndexComparisonTable(sourceIndexes, targetIndexes, indexMatch) {
            const methods = ['API', 'EXP', 'STR', 'MNE', 'CFG', 'PRO'];
            const hasAnyIndex = methods.some(m => sourceIndexes[m] || targetIndexes[m]);

            if (!hasAnyIndex) {
                return '<div style="color: var(--text-muted);">No index data available</div>';
            }

            let html = '<table style="width:100%; font-family: var(--font-mono); font-size: 0.65rem;">';
            html += '<thead><tr style="color: var(--text-muted);"><th style="text-align:left; padding:2px 4px;">Method</th><th style="text-align:left; padding:2px 4px;">Source Hash</th><th style="text-align:left; padding:2px 4px;">Target Hash</th><th></th></tr></thead>';
            html += '<tbody>';

            methods.forEach(method => {
                const sourceHash = sourceIndexes[method];
                const targetHash = targetIndexes[method];
                if (!sourceHash && !targetHash) return;

                const isMatch = sourceHash && targetHash && sourceHash === targetHash;
                const rowClass = isMatch ? 'style="background: rgba(0,200,83,0.1);"' : '';
                const matchIcon = isMatch ? '<span style="color: var(--color-set);">✓</span>' : (sourceHash && targetHash ? '<span style="color: var(--color-crafted);">✗</span>' : '');

                html += `<tr ${rowClass}>
                    <td style="padding:2px 4px; font-weight:500; color: var(--color-magic);">${method}</td>
                    <td style="padding:2px 4px; word-break:break-all; color: ${isMatch ? 'var(--color-set)' : 'var(--text-secondary)'};">${sourceHash ? sourceHash.substring(0, 16) + '...' : '—'}</td>
                    <td style="padding:2px 4px; word-break:break-all; color: ${isMatch ? 'var(--color-set)' : 'var(--text-secondary)'};">${targetHash ? targetHash.substring(0, 16) + '...' : '—'}</td>
                    <td style="padding:2px 4px; text-align:center;">${matchIcon}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            return html;
        }

        // Helper: Render index inline for a single column
        function renderIndexInline(indexes, otherIndexes, indexMatch) {
            // Include all index types: original + new CAL, CON, APS
            const methods = ['EXP', 'STR', 'CAL', 'API', 'APS', 'CON', 'MNE', 'CFG', 'PRO'];
            const hasAnyIndex = methods.some(m => indexes[m]);

            if (!hasAnyIndex) {
                return '<div style="color: var(--text-muted); font-style: italic;">No index data</div>';
            }

            // Method descriptions for tooltips
            const methodDesc = {
                'EXP': 'Export ordinal (100% reliable)',
                'STR': 'Unique strings (99% reliable)',
                'CAL': 'Sorted callee names (95% reliable)',
                'API': 'API call sequence (90% reliable)',
                'APS': 'Sorted APIs (order-independent)',
                'CON': 'Sorted constants (85% reliable)',
                'MNE': 'Mnemonic sequence (80% reliable)',
                'CFG': 'Control flow structure (75% reliable)',
                'PRO': 'Prologue bytes (60% reliable)'
            };

            return methods.filter(m => indexes[m]).map(method => {
                const hash = indexes[method];
                const otherHash = otherIndexes?.[method];
                const isMatch = hash && otherHash && hash === otherHash;
                const shortHash = hash.length > 20 ? hash.substring(0, 16) + '...' : hash;
                const matchIcon = isMatch ? ' <span style="color: var(--color-set);">✓</span>' : '';
                const desc = methodDesc[method] || method;

                return `<div class="index-row" style="margin-bottom: 4px;">
                    <span class="callee-tag ${isMatch ? 'match' : ''}" style="font-weight: 500;" title="${desc}">${method}</span>
                    <span style="font-family: var(--font-mono); font-size: 0.6rem; color: ${isMatch ? 'var(--color-set)' : 'var(--text-muted)'}; word-break: break-all;" title="${hash}">${shortHash}${matchIcon}</span>
                </div>`;
            }).join('');
        }

        // Helper: Render constants as tags
        // Constants can be in format: "address||value" or just numeric values
        function renderConstantTags(constants, otherConstants) {
            if (!constants || constants.length === 0) {
                return '<span style="color: var(--text-muted);">No constants</span>';
            }
            // Helper to extract value from constant (handles both formats)
            const extractValue = (c) => {
                if (typeof c === 'string' && c.includes('||')) {
                    const parts = c.split('||');
                    return parts.length >= 2 ? parts[1] : c;
                }
                return c;
            };
            // Build set of other constant values for comparison
            const otherValues = new Set((otherConstants || []).map(extractValue));

            return constants.slice(0, 15).map(c => {
                const val = extractValue(c);
                const isShared = otherValues.has(val);
                // Try to parse as number for hex display
                let displayVal = val;
                let numVal = null;
                if (typeof val === 'string' && val.startsWith('0x')) {
                    numVal = parseInt(val, 16);
                    displayVal = val.toUpperCase();
                } else if (typeof val === 'number') {
                    numVal = val;
                    displayVal = val >= 256 ? `0x${val.toString(16).toUpperCase()}` : val;
                } else if (typeof val === 'string' && !isNaN(parseInt(val))) {
                    numVal = parseInt(val);
                    displayVal = numVal >= 256 ? `0x${numVal.toString(16).toUpperCase()}` : numVal;
                }
                return `<span class="callee-tag ${isShared ? 'shared' : ''}" title="${val}">${displayVal}</span>`;
            }).join('') + (constants.length > 15 ? `<span class="callee-tag">+${constants.length - 15} more</span>` : '');
        }

        // Helper: Render globals as list
        // Globals can be in format: "address|name|value" or "address|name"
        function renderGlobalRefs(globals) {
            if (!globals || globals.length === 0) {
                return '<div class="string-ref" style="color: var(--text-muted);">No global references</div>';
            }
            return globals.slice(0, 8).map(g => {
                if (typeof g === 'string') {
                    const parts = g.split('|');
                    const rva = parts[0] || '';
                    const name = parts[1] || '';
                    const value = parts[2] || '';
                    let display = `<span style="color: var(--addr-color);">${rva}</span>`;
                    if (name) display += ` <span style="color: var(--text-primary);">${escapeHtml(name)}</span>`;
                    if (value) display += ` = <span style="color: var(--color-magic);">${escapeHtml(value.length > 30 ? value.substring(0, 30) + '...' : value)}</span>`;
                    return `<div class="string-ref">${display}</div>`;
                }
                return `<div class="string-ref">${escapeHtml(String(g))}</div>`;
            }).join('') + (globals.length > 8 ? `<div class="string-ref" style="color: var(--text-muted);">+${globals.length - 8} more</div>` : '');
        }

        // Helper: Render function tags with color coding
        function renderFunctionTags(tags, otherTags = []) {
            if (!tags || tags.length === 0) {
                return '<span style="color: var(--text-muted); font-style: italic;">No tags</span>';
            }

            const otherSet = new Set(otherTags || []);

            // Tag category colors
            const tagColors = {
                'PARAM_': 'var(--color-magic)',      // Blue for parameter counts
                'PROP_': 'var(--color-rare)',        // Yellow for properties
                'STRUCT_': 'var(--color-unique)',    // Gold for structs
                'LOOP_': 'var(--color-set)',         // Green for loops
                'API_': 'var(--color-crafted)',      // Orange for API
                'STR_': '#9966cc'                    // Purple for strings
            };

            const getTagColor = (tag) => {
                for (const [prefix, color] of Object.entries(tagColors)) {
                    if (tag.startsWith(prefix)) return color;
                }
                return 'var(--text-secondary)';  // Default gray
            };

            return tags.map(tag => {
                const isShared = otherSet.has(tag);
                const color = getTagColor(tag);
                const matchClass = isShared ? 'shared' : '';
                return `<span class="callee-tag ${matchClass}" style="background: ${isShared ? color : 'var(--bg-tertiary)'}; color: ${isShared ? 'white' : color}; border: 1px solid ${color};" title="${tag}">${escapeHtml(tag)}</span>`;
            }).join(' ');
        }

        // Helper: Render function type badge
        function renderFunctionTypeBadge(funcType) {
            if (!funcType) return '';

            const typeStyles = {
                'export': { bg: 'var(--color-unique)', icon: '📤', label: 'Export' },
                'ordinal': { bg: 'var(--color-magic)', icon: '#', label: 'Ordinal' },
                'thunk': { bg: 'var(--color-rare)', icon: '→', label: 'Thunk' },
                'internal': { bg: 'var(--text-muted)', icon: '•', label: 'Internal' },
                'entry': { bg: 'var(--color-set)', icon: '▶', label: 'Entry' },
                'external': { bg: 'var(--color-crafted)', icon: '⬆', label: 'External' }
            };

            const style = typeStyles[funcType] || typeStyles['internal'];
            return `<span class="function-type-badge" style="background: ${style.bg}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; margin-left: 8px;" title="${funcType}">${style.icon} ${style.label}</span>`;
        }

        // Helper: Format instruction for display
        function formatInstruction(instr) {
            if (typeof instr === 'string') return instr;
            return `<div class="instruction-line">
                <span class="addr">${instr.address || ''}</span>
                <span class="mnemonic">${instr.mnemonic || ''}</span>
                <span class="operands">${instr.operands || ''}</span>
            </div>`;
        }

        // Helper: Render callee tags with split row display (matched vs unique)
        function renderCalleeSplitTags(callees, otherCallees = [], isSource = true) {
            if (!callees || callees.length === 0) return '<div class="callee-row"><span class="callee-tag" style="color: var(--text-muted);">No callees</span></div>';

            const getCalleeName = (c) => c.name || c;
            const otherNames = new Set(otherCallees.map(getCalleeName));

            // Split into matched and unique
            const matched = callees.filter(c => otherNames.has(getCalleeName(c)));
            const unique = callees.filter(c => !otherNames.has(getCalleeName(c)));

            // Render matched callees row
            let matchedHtml = '';
            if (matched.length > 0) {
                const matchedTags = matched.slice(0, 12).map(c => {
                    const name = getCalleeName(c);
                    const isKnown = !name.startsWith('FUN_') && !name.startsWith('LAB_');
                    return `<span class="callee-tag match">${name}</span>`;
                }).join('');
                const moreCount = matched.length > 12 ? `<span class="callee-tag" style="color: var(--text-muted);">+${matched.length - 12}</span>` : '';
                matchedHtml = `<div class="callee-row callee-row-matched">
                    <span class="callee-row-label">✓ Matched (${matched.length}):</span>
                    <div class="callee-row-tags">${matchedTags}${moreCount}</div>
                </div>`;
            }

            // Render unique callees row
            let uniqueHtml = '';
            if (unique.length > 0) {
                const uniqueTags = unique.slice(0, 8).map(c => {
                    const name = getCalleeName(c);
                    const isKnown = !name.startsWith('FUN_') && !name.startsWith('LAB_');
                    const tagClass = isSource ? 'callee-tag source-unique' : 'callee-tag target-unique';
                    return `<span class="${tagClass}">${name}</span>`;
                }).join('');
                const moreCount = unique.length > 8 ? `<span class="callee-tag" style="color: var(--text-muted);">+${unique.length - 8}</span>` : '';
                const label = isSource ? '← Only here' : '→ Only here';
                uniqueHtml = `<div class="callee-row callee-row-unique">
                    <span class="callee-row-label">${label} (${unique.length}):</span>
                    <div class="callee-row-tags">${uniqueTags}${moreCount}</div>
                </div>`;
            }

            // If no matched, show a note
            if (matched.length === 0 && unique.length > 0) {
                matchedHtml = `<div class="callee-row callee-row-matched">
                    <span class="callee-row-label" style="color: var(--text-muted);">No matching callees</span>
                </div>`;
            }

            return matchedHtml + uniqueHtml;
        }

        // Legacy: Render callee tags (simple version for backward compatibility)
        function renderCalleeTags(callees, matchingCallees = []) {
            if (!callees || callees.length === 0) return '<span class="callee-tag">No callees</span>';
            const matchSet = new Set(matchingCallees.map(c => c.name || c));
            return callees.slice(0, 20).map(callee => {
                const name = callee.name || callee;
                const isKnown = !name.startsWith('FUN_') && !name.startsWith('LAB_');
                const isMatch = matchSet.has(name);
                const classes = ['callee-tag'];
                if (isMatch) classes.push('match');
                else if (isKnown) classes.push('known');
                return `<span class="${classes.join(' ')}">${name}</span>`;
            }).join('') + (callees.length > 20 ? `<span class="callee-tag">+${callees.length - 20} more</span>` : '');
        }


        // Helper: Render side-by-side callee comparison table
        function renderCalleeComparisonTable(sourceCallees, targetCallees, sourceVersion, targetVersion) {
            if ((!sourceCallees || sourceCallees.length === 0) && (!targetCallees || targetCallees.length === 0)) {
                return '<div style="color: var(--text-muted); font-style: italic;">No callees in either version</div>';
            }

            // Normalize callee names
            const getCalleeName = (c) => c.name || c;

            // Create lookup sets
            const sourceNames = new Set(sourceCallees.map(getCalleeName));
            const targetNames = new Set(targetCallees.map(getCalleeName));

            // Build rows: matched first, then source-only, then target-only
            const rows = [];

            // Matched callees (in both)
            const matched = sourceCallees.filter(c => targetNames.has(getCalleeName(c)));
            matched.forEach(callee => {
                const name = getCalleeName(callee);
                const targetCallee = targetCallees.find(c => getCalleeName(c) === name);
                rows.push({
                    type: 'match',
                    sourceName: name,
                    sourceAddr: callee.address || '',
                    targetName: name,
                    targetAddr: targetCallee?.address || ''
                });
            });

            // Source-only callees
            const sourceOnly = sourceCallees.filter(c => !targetNames.has(getCalleeName(c)));
            sourceOnly.forEach(callee => {
                const name = getCalleeName(callee);
                rows.push({
                    type: 'source-only',
                    sourceName: name,
                    sourceAddr: callee.address || '',
                    targetName: '',
                    targetAddr: ''
                });
            });

            // Target-only callees
            const targetOnly = targetCallees.filter(c => !sourceNames.has(getCalleeName(c)));
            targetOnly.forEach(callee => {
                const name = getCalleeName(callee);
                rows.push({
                    type: 'target-only',
                    sourceName: '',
                    sourceAddr: '',
                    targetName: name,
                    targetAddr: callee.address || ''
                });
            });

            // Limit displayed rows
            const maxRows = 25;
            const displayRows = rows.slice(0, maxRows);
            const remaining = rows.length - maxRows;

            // Build HTML table
            let html = `<table class="callee-comparison-table">
                <thead>
                    <tr>
                        <th style="width: 20px;"></th>
                        <th>Source (${sourceVersion?.split('/')[1] || 'Source'})</th>
                        <th>Target (${targetVersion?.split('/')[1] || 'Target'})</th>
                    </tr>
                </thead>
                <tbody>`;

            displayRows.forEach(row => {
                let statusIcon = '';
                let sourceTdClass = '';
                let targetTdClass = '';

                if (row.type === 'match') {
                    statusIcon = '<span class="status-icon match">✓</span>';
                    sourceTdClass = 'match-cell';
                    targetTdClass = 'match-cell';
                } else if (row.type === 'source-only') {
                    statusIcon = '<span class="status-icon diff">←</span>';
                    sourceTdClass = 'source-only';
                    targetTdClass = 'empty-cell';
                } else {
                    statusIcon = '<span class="status-icon diff">→</span>';
                    sourceTdClass = 'empty-cell';
                    targetTdClass = 'target-only';
                }

                html += `<tr>
                    <td>${statusIcon}</td>
                    <td class="${sourceTdClass}">${row.sourceName ? `<span>${row.sourceName}</span>` : '—'}</td>
                    <td class="${targetTdClass}">${row.targetName ? `<span>${row.targetName}</span>` : '—'}</td>
                </tr>`;
            });

            html += '</tbody></table>';

            if (remaining > 0) {
                html += `<div style="color: var(--text-muted); font-size: 0.65rem; margin-top: 4px;">+${remaining} more callees</div>`;
            }

            // Summary stats
            const matchCount = matched.length;
            const totalUnique = sourceNames.size + targetNames.size - matchCount;
            const matchPct = totalUnique > 0 ? Math.round((matchCount / Math.max(sourceNames.size, targetNames.size)) * 100) : 0;

            return `<div style="margin-bottom: 8px; font-size: 0.7rem;">
                <span style="color: var(--color-set);">✓ ${matchCount} matched</span> · 
                <span style="color: var(--color-rare);">${sourceOnly.length} source-only</span> · 
                <span style="color: var(--color-magic);">${targetOnly.length} target-only</span>
                ${matchPct > 0 ? `<span class="match-badge" style="margin-left: 8px;">${matchPct}% overlap</span>` : ''}
            </div>` + html;
        }

        // Helper: Render string references
        // Strings can be in format: "address|name|value" or just "value"
        function renderStringRefs(strings) {
            if (!strings || strings.length === 0) return '<div class="string-ref" style="color: var(--text-muted);">No string references</div>';
            return strings.slice(0, 10).map(s => {
                let displayStr = s;
                let addr = '';
                // Parse address|name|value format
                if (typeof s === 'string' && s.includes('|')) {
                    const parts = s.split('|');
                    if (parts.length >= 3) {
                        addr = parts[0];
                        displayStr = parts[2]; // value is third part
                    } else if (parts.length === 2) {
                        addr = parts[0];
                        displayStr = parts[1];
                    }
                }
                const truncated = displayStr.length > 60 ? displayStr.substring(0, 60) + '...' : displayStr;
                const addrSpan = addr ? `<span style="color: var(--addr-color); font-size: 0.85em;">${addr}</span> ` : '';
                return `<div class="string-ref">${addrSpan}"${escapeHtml(truncated)}"</div>`;
            }).join('') +
                (strings.length > 10 ? `<div class="string-ref" style="color: var(--text-muted);">+${strings.length - 10} more strings</div>` : '');
        }

        // Helper: Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================================
        // COMPARE PANEL - Row-based aligned comparison view
        // ============================================================

        // Render a single comparison row
        function renderCompareRow(sourceVal, metric, targetVal, matchType) {
            const matchIcons = {
                'exact': '✓',
                'close': '≈',
                'diff': '✗',
                'missing': '—'
            };
            const icon = matchIcons[matchType] || '—';
            const sourceDisplay = sourceVal !== null && sourceVal !== undefined ? sourceVal : '—';
            const targetDisplay = targetVal !== null && targetVal !== undefined ? targetVal : '—';

            const srcCopyable = sourceDisplay !== '—' ? 'copyable' : '';
            const tgtCopyable = targetDisplay !== '—' ? 'copyable' : '';
            const srcEscaped = escapeHtml(String(sourceDisplay)).replace(/'/g, "\\'");
            const tgtEscaped = escapeHtml(String(targetDisplay)).replace(/'/g, "\\'");
            const srcOnclick = srcCopyable ? `onclick="copyToClipboard('${srcEscaped}', this); event.stopPropagation();"` : '';
            const tgtOnclick = tgtCopyable ? `onclick="copyToClipboard('${tgtEscaped}', this); event.stopPropagation();"` : '';

            return `
                <div class="compare-row">
                    <div class="source ${srcCopyable}" title="${escapeHtml(String(sourceDisplay))}" ${srcOnclick}>${escapeHtml(String(sourceDisplay))}</div>
                    <div class="metric">${escapeHtml(metric)}</div>
                    <div class="target ${tgtCopyable}" title="${escapeHtml(String(targetDisplay))}" ${tgtOnclick}>${escapeHtml(String(targetDisplay))}</div>
                    <div class="match-icon ${matchType}">${icon}</div>
                </div>
            `;
        }

        // Determine match type based on values
        function getMatchType(sourceVal, targetVal, tolerance = 0) {
            if (sourceVal === null || sourceVal === undefined || targetVal === null || targetVal === undefined) {
                return 'missing';
            }
            if (sourceVal === targetVal) {
                return 'exact';
            }
            if (typeof sourceVal === 'number' && typeof targetVal === 'number' && tolerance > 0) {
                const diff = Math.abs(sourceVal - targetVal);
                const avg = (sourceVal + targetVal) / 2;
                if (avg > 0 && diff / avg <= tolerance) {
                    return 'close';
                }
            }
            return 'diff';
        }

        // Render a section with header and rows
        function renderCompareSection(title, rows, summaryText = '', collapsed = false) {
            const collapsedClass = collapsed ? ' collapsed' : '';
            const summaryHtml = summaryText ? `<span class="compare-section-summary">${summaryText}</span>` : '';

            return `
                <div class="compare-section${collapsedClass}">
                    <div class="compare-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
                        <span class="compare-section-title">${escapeHtml(title)}</span>
                        ${summaryHtml}
                    </div>
                    <div class="compare-section-content">
                        <div class="compare-columns-header">
                            <span class="compare-col-label source">Source</span>
                            <span class="compare-col-label metric">Metric</span>
                            <span class="compare-col-label target">Target</span>
                            <span class="compare-col-label match"></span>
                        </div>
                        ${rows}
                    </div>
                </div>
            `;
        }

        // Render list comparison (callees, strings, etc.)
        function renderCompareListSection(title, sourceItems, targetItems, collapsed = false, itemType = 'default') {
            // Get normalizer for this item type
            const normalizer = getNormalizer(itemType);

            // Pair items using smart normalization
            const pairs = pairItems(sourceItems, targetItems, normalizer);

            // Count matches
            const matchCount = pairs.filter(p => p.matchType === 'exact' || p.matchType === 'normalized').length;
            const total = pairs.length;
            const exactCount = pairs.filter(p => p.matchType === 'exact').length;
            const normalizedCount = pairs.filter(p => p.matchType === 'normalized').length;

            let summaryText = 'empty';
            const allMatch = matchCount === total && total > 0;
            const checkmark = allMatch ? '<span class="match-checkmark">✓</span> ' : '';
            if (total > 0) {
                if (normalizedCount > 0) {
                    summaryText = `${checkmark}<span class="match-count">${exactCount}</span>+<span class="match-count-normalized">${normalizedCount}</span>/${total}`;
                } else {
                    summaryText = `${checkmark}<span class="match-count">${matchCount}</span>/${total}`;
                }
            }

            const collapsedClass = collapsed ? ' collapsed' : '';

            // Build paired rows table
            let listHtml = '<div class="compare-paired-list">';

            if (pairs.length === 0) {
                listHtml += '<div class="compare-paired-empty">No items</div>';
            } else {
                // Header row
                listHtml += `
                    <div class="compare-paired-header">
                        <span class="paired-col-source">Source</span>
                        <span class="paired-col-match"></span>
                        <span class="paired-col-target">Target</span>
                    </div>
                `;

                // Data rows
                pairs.forEach(pair => {
                    const srcDisplay = pair.source ? formatListItem(pair.source, itemType) : '—';
                    const tgtDisplay = pair.target ? formatListItem(pair.target, itemType) : '—';
                    const srcFull = pair.source ? escapeHtml(String(pair.source)) : '';
                    const tgtFull = pair.target ? escapeHtml(String(pair.target)) : '';

                    let matchIcon, matchClass;
                    switch (pair.matchType) {
                        case 'exact':
                            matchIcon = '✓';
                            matchClass = 'match-exact';
                            break;
                        case 'normalized':
                            matchIcon = '≈';
                            matchClass = 'match-normalized';
                            break;
                        case 'source-only':
                            matchIcon = '←';
                            matchClass = 'match-source-only';
                            break;
                        case 'target-only':
                            matchIcon = '→';
                            matchClass = 'match-target-only';
                            break;
                        default:
                            matchIcon = '?';
                            matchClass = '';
                    }

                    const srcCopyable = pair.source ? 'copyable' : '';
                    const tgtCopyable = pair.target ? 'copyable' : '';
                    const srcOnclick = pair.source ? `onclick="copyToClipboard('${srcFull.replace(/'/g, "\\'")}', this); event.stopPropagation();"` : '';
                    const tgtOnclick = pair.target ? `onclick="copyToClipboard('${tgtFull.replace(/'/g, "\\'")}', this); event.stopPropagation();"` : '';

                    listHtml += `
                        <div class="compare-paired-row ${matchClass}">
                            <span class="paired-col-source ${srcCopyable}" title="${srcFull}" ${srcOnclick}>${escapeHtml(srcDisplay)}</span>
                            <span class="paired-col-match">${matchIcon}</span>
                            <span class="paired-col-target ${tgtCopyable}" title="${tgtFull}" ${tgtOnclick}>${escapeHtml(tgtDisplay)}</span>
                        </div>
                    `;
                });
            }

            listHtml += '</div>';

            return `
                <div class="compare-section${collapsedClass}">
                    <div class="compare-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
                        <span class="compare-section-title">${escapeHtml(title)}</span>
                        <span class="compare-section-summary">${summaryText}</span>
                    </div>
                    <div class="compare-section-content">
                        ${listHtml}
                    </div>
                </div>
            `;
        }

        // Format list item for display based on item type
        function formatListItem(item, itemType = 'default') {
            let display = String(item);

            if (display.includes('|')) {
                const parts = display.split('|');

                switch (itemType) {
                    case 'callees':
                    case 'callers':
                        // Format: "name|address" or "name@suffix|address" - show name
                        display = parts[0] || display;
                        // Strip @suffix if present
                        const atIdx = display.indexOf('@');
                        if (atIdx > 0) {
                            display = display.substring(0, atIdx);
                        }
                        break;
                    case 'strings':
                        // Format: "address|label|value" - show value (last part)
                        display = parts[parts.length - 1] || parts[0];
                        break;
                    case 'constants':
                        // Format: "address||value" - show value (last non-empty part)
                        display = parts[parts.length - 1] || parts[0];
                        break;
                    case 'globals':
                        // Format: "name|address" - show name
                        display = parts[0] || display;
                        break;
                    default:
                        // Default: prefer last part
                        display = parts[parts.length - 1] || parts[0];
                }
            }

            // Truncate long items
            if (display.length > 30) {
                display = display.substring(0, 27) + '...';
            }
            return display;
        }

        // Normalization functions for matching items across versions
        // Each returns a normalized key for comparison

        // Normalize string references: extract value, normalize paths
        function normalizeString(item) {
            const str = String(item);
            // Format: "address|label|value" - extract value (3rd part)
            const parts = str.split('|');
            let value = parts.length >= 3 ? parts[2] : (parts.length >= 2 ? parts[1] : str);

            // Normalize file paths - extract basename and lowercase
            if (value.includes('\\') || value.includes('/') || value.match(/\.\w{1,4}$/)) {
                // Extract filename from path
                value = value.replace(/\\/g, '/');
                const lastSlash = value.lastIndexOf('/');
                if (lastSlash >= 0) {
                    value = value.substring(lastSlash + 1);
                }
            }
            return value.toLowerCase().trim();
        }

        // Normalize callee/caller names: extract function name before @ or |
        function normalizeCallee(item) {
            const str = String(item);
            // Format: "name|address" or "name@suffix|address"
            const parts = str.split('|');
            let name = parts[0] || str;
            // Remove @suffix (like @6fba4400)
            const atIdx = name.indexOf('@');
            if (atIdx > 0) {
                name = name.substring(0, atIdx);
            }
            return name.toLowerCase().trim();
        }

        // Normalize constants: extract value (3rd part after ||)
        function normalizeConstant(item) {
            const str = String(item);
            // Format: "address||value"
            const parts = str.split('|');
            // Value is the 3rd part (index 2) since format is addr||val (empty middle)
            const value = parts.length >= 3 ? parts[2] : str;
            // Normalize hex values
            return value.toLowerCase().replace(/^0x/, '').trim();
        }

        // Normalize globals: extract name or address
        function normalizeGlobal(item) {
            const str = String(item);
            const parts = str.split('|');
            // Prefer name (2nd part) if present, else address
            const name = parts.length >= 2 && parts[1] ? parts[1] : parts[0];
            return name.toLowerCase().trim();
        }

        // Get normalizer function based on item type
        function getNormalizer(itemType) {
            switch (itemType) {
                case 'strings': return normalizeString;
                case 'callees': return normalizeCallee;
                case 'callers': return normalizeCallee;
                case 'constants': return normalizeConstant;
                case 'globals': return normalizeGlobal;
                default: return (x) => String(x).toLowerCase();
            }
        }

        // Pair items from source and target using normalization
        // Returns array of {source, target, matchType} objects
        function pairItems(sourceItems, targetItems, normalizeFunc) {
            const pairs = [];
            const usedTargetIndices = new Set();

            // Build normalized lookup for targets
            const targetNormalized = targetItems.map(t => normalizeFunc(t));

            // First pass: find matches for each source item
            sourceItems.forEach(srcItem => {
                const srcKey = normalizeFunc(srcItem);
                let matchIdx = -1;
                let matchType = 'source-only';

                // Find first unused target with matching normalized key
                for (let i = 0; i < targetItems.length; i++) {
                    if (!usedTargetIndices.has(i) && targetNormalized[i] === srcKey) {
                        matchIdx = i;
                        // Check if exact match (original strings equal)
                        matchType = String(srcItem).toLowerCase() === String(targetItems[i]).toLowerCase()
                            ? 'exact' : 'normalized';
                        break;
                    }
                }

                if (matchIdx >= 0) {
                    pairs.push({
                        source: srcItem,
                        target: targetItems[matchIdx],
                        matchType
                    });
                    usedTargetIndices.add(matchIdx);
                } else {
                    pairs.push({ source: srcItem, target: null, matchType: 'source-only' });
                }
            });

            // Second pass: add unmatched targets
            targetItems.forEach((targetItem, i) => {
                if (!usedTargetIndices.has(i)) {
                    pairs.push({ source: null, target: targetItem, matchType: 'target-only' });
                }
            });

            // Sort: matched first, then source-only, then target-only
            const order = { 'exact': 0, 'normalized': 1, 'source-only': 2, 'target-only': 3 };
            pairs.sort((a, b) => order[a.matchType] - order[b.matchType]);

            return pairs;
        }

        // Render hash comparison
        function renderCompareHashSection(title, sourceHash, targetHash, collapsed = false) {
            const isMatch = sourceHash && targetHash && sourceHash === targetHash;
            const matchClass = isMatch ? ' match' : '';
            const collapsedClass = collapsed ? ' collapsed' : '';
            const summaryText = isMatch ? '<span class="match-count">✓ MATCH</span>' : 'different';

            const srcCopyable = sourceHash ? 'copyable' : '';
            const tgtCopyable = targetHash ? 'copyable' : '';
            const srcOnclick = sourceHash ? `onclick="copyToClipboard('${sourceHash}', this); event.stopPropagation();"` : '';
            const tgtOnclick = targetHash ? `onclick="copyToClipboard('${targetHash}', this); event.stopPropagation();"` : '';

            return `
                <div class="compare-section${collapsedClass}">
                    <div class="compare-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
                        <span class="compare-section-title">${escapeHtml(title)}</span>
                        <span class="compare-section-summary">${summaryText}</span>
                    </div>
                    <div class="compare-section-content">
                        <div class="compare-hash-row">
                            <div class="compare-hash-value${matchClass}">
                                <div class="hash-label">Source</div>
                                <span class="${srcCopyable}" ${srcOnclick}>${sourceHash || '—'}</span>
                            </div>
                            <div class="compare-hash-value${matchClass}">
                                <div class="hash-label">Target</div>
                                <span class="${tgtCopyable}" ${tgtOnclick}>${targetHash || '—'}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Render signature comparison
        function renderCompareSignatureSection(sourceData, targetData, collapsed = false) {
            const collapsedClass = collapsed ? ' collapsed' : '';

            const sourceConv = sourceData.calling_convention || '—';
            const targetConv = targetData?.calling_convention || '—';
            const sourceRet = sourceData.return_type || '—';
            const targetRet = targetData?.return_type || '—';
            const sourceSig = sourceData.signature || '—';
            const targetSig = targetData?.signature || '—';

            const convMatch = sourceConv === targetConv;
            const retMatch = sourceRet === targetRet;

            const srcSigCopyable = sourceSig !== '—' ? 'copyable' : '';
            const tgtSigCopyable = targetSig !== '—' ? 'copyable' : '';
            const srcSigEscaped = escapeHtml(sourceSig).replace(/'/g, "\\'");
            const tgtSigEscaped = escapeHtml(targetSig).replace(/'/g, "\\'");
            const srcSigOnclick = srcSigCopyable ? `onclick="copyToClipboard('${srcSigEscaped}', this); event.stopPropagation();"` : '';
            const tgtSigOnclick = tgtSigCopyable ? `onclick="copyToClipboard('${tgtSigEscaped}', this); event.stopPropagation();"` : '';

            return `
                <div class="compare-section${collapsedClass}">
                    <div class="compare-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
                        <span class="compare-section-title">Signature</span>
                        <span class="compare-section-summary">${convMatch && retMatch ? '<span class="match-count">✓</span>' : ''}</span>
                    </div>
                    <div class="compare-section-content">
                        <div class="compare-columns-header">
                            <span class="compare-col-label source">Source</span>
                            <span class="compare-col-label metric">Field</span>
                            <span class="compare-col-label target">Target</span>
                            <span class="compare-col-label match"></span>
                        </div>
                        ${renderCompareRow(sourceConv, 'Convention', targetConv, convMatch ? 'exact' : 'diff')}
                        ${renderCompareRow(sourceRet, 'Return', targetRet, retMatch ? 'exact' : 'diff')}
                        <div class="compare-signature-row">
                            <div class="sig-label">Source Signature</div>
                            <span class="${srcSigCopyable}" ${srcSigOnclick}>${escapeHtml(sourceSig)}</span>
                        </div>
                        <div class="compare-signature-row">
                            <div class="sig-label">Target Signature</div>
                            <span class="${tgtSigCopyable}" ${tgtSigOnclick}>${escapeHtml(targetSig)}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Render Match Score Breakdown section showing tier details and feature contributions
        function renderMatchScoreBreakdown(identityMatch, sourceVersion, targetVersion) {
            if (!identityMatch) return '';

            const { tier, confidence, breakdown } = identityMatch;
            const tier1 = breakdown?.tier1 || { matched: false, reason: null };
            const tier2 = breakdown?.tier2 || { score: 0, vectorBreakdown: {}, valueBonusBreakdown: {} };
            const tier3 = breakdown?.tier3 || { plausible: true, warnings: [] };

            let html = '<div class="score-breakdown">';

            // Tier 1: Hash Matches
            const tier1Class = tier1.matched ? 'tier-matched' : '';
            html += `
                <div class="score-breakdown-tier ${tier1Class}">
                    <div class="tier-header">
                        <span class="tier-icon">${tier1.matched ? '🔒' : '○'}</span>
                        <span class="tier-label">Tier 1: Hash Match</span>
                        <span class="tier-status">${tier1.matched ? 'MATCHED' : 'No Match'}</span>
                    </div>
                    ${tier1.matched && tier1.reason ? `<div class="tier-reason">${escapeHtml(tier1.reason)}</div>` : ''}
                </div>
            `;

            // Tier 2: Vector Similarity (only show details if Tier 1 didn't match)
            if (!tier1.matched) {
                const vectorBreakdown = tier2.vectorBreakdown || {};
                const valueBonusBreakdown = tier2.valueBonusBreakdown || {};
                const baseScore = tier2.score || 0;
                const valueBonus = tier2.valueBonus || 0;
                const combinedScore = tier2.combinedScore || baseScore;

                const tier2Class = combinedScore >= 70 ? 'tier-matched' : combinedScore >= 40 ? 'tier-partial' : '';

                html += `
                    <div class="score-breakdown-tier ${tier2Class}">
                        <div class="tier-header">
                            <span class="tier-icon">${combinedScore >= 70 ? '🎯' : combinedScore >= 40 ? '◐' : '○'}</span>
                            <span class="tier-label">Tier 2: Vector Similarity</span>
                            <span class="tier-status">${combinedScore}% (base ${baseScore} + bonus ${valueBonus.toFixed(1)})</span>
                        </div>
                `;

                // Feature contribution table
                const features = Object.entries(vectorBreakdown)
                    .filter(([_, data]) => data.val1 !== undefined || data.val2 !== undefined)
                    .sort((a, b) => (b[1].contribution || 0) - (a[1].contribution || 0));

                if (features.length > 0) {
                    html += '<table class="score-feature-table"><tbody>';
                    html += '<tr class="feat-header"><th>Feature</th><th>Source</th><th>Target</th><th>Sim%</th><th>Contrib</th></tr>';

                    for (const [featName, data] of features.slice(0, 10)) {
                        const sim = data.similarity || 0;
                        const contrib = data.contribution || 0;
                        const contribPct = Math.min(100, contrib * 10); // Scale for display
                        const barClass = sim >= 80 ? 'high' : sim >= 50 ? 'medium' : 'low';

                        html += `
                            <tr>
                                <td class="feat-name">${featName.replace(/_/g, ' ')}</td>
                                <td class="feat-val">${data.val1 ?? '—'}</td>
                                <td class="feat-val">${data.val2 ?? '—'}</td>
                                <td class="feat-sim ${barClass}">${sim}%</td>
                                <td class="feat-contrib">
                                    <div class="contrib-bar">
                                        <div class="contrib-bar-fill ${barClass}" style="width: ${contribPct}%"></div>
                                    </div>
                                    <span class="contrib-value">${contrib.toFixed(2)}</span>
                                </td>
                            </tr>
                        `;
                    }
                    html += '</tbody></table>';
                }

                // Value bonuses
                const valueBonuses = Object.entries(valueBonusBreakdown)
                    .filter(([_, data]) => data.bonus > 0);

                if (valueBonuses.length > 0) {
                    html += '<div class="score-value-bonuses"><span class="bonuses-label">Value Bonuses:</span>';
                    for (const [bonusType, data] of valueBonuses) {
                        const label = bonusType.replace(/_/g, ' ').replace('overlap', '');
                        html += `<span class="bonus-tag" title="${data.jaccard}% Jaccard overlap">+${data.bonus.toFixed(1)} ${label}</span>`;
                    }
                    html += '</div>';
                }

                html += '</div>';
            }

            // Tier 3: Validation Warnings
            if (tier3.warnings && tier3.warnings.length > 0) {
                const warningClass = tier3.plausible ? '' : 'tier-warning';
                html += `
                    <div class="score-breakdown-tier ${warningClass}">
                        <div class="tier-header">
                            <span class="tier-icon">${tier3.plausible ? '⚠️' : '❌'}</span>
                            <span class="tier-label">Tier 3: Validation</span>
                            <span class="tier-status">${tier3.plausible ? 'Warnings' : 'IMPLAUSIBLE'}</span>
                        </div>
                        <div class="score-warnings">
                            ${tier3.warnings.map(w => `<div class="warning-item">${escapeHtml(w)}</div>`).join('')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        // Find top N alternate function matches for a source function in a target version
        // Uses sequential filtering: param count -> calling convention -> string count -> similar size
        function findTopAlternateMatches(sourceFuncData, sourceVersion, targetVersion, topN = 3, excludeAddress = null) {
            if (!currentFuncData?.functions) return [];

            const alternates = [];

            // Extract source properties for filtering
            const sourceParamCount = sourceFuncData.param_counts?.[sourceVersion] || 0;
            const sourceCallingConv = sourceFuncData.calling_convention || '';
            const sourceStringCount = sourceFuncData.string_counts?.[sourceVersion] || (sourceFuncData.strings?.[sourceVersion]?.length || 0);
            const sourceSize = sourceFuncData.sizes?.[sourceVersion] || 0;

            // Build source object for comparison (after filtering)
            const sourceObj = {
                size: sourceSize,
                callees: sourceFuncData.callees?.[sourceVersion] || [],
                strings: sourceFuncData.strings?.[sourceVersion] || [],
                constants: sourceFuncData.constants?.[sourceVersion] || [],
                globals: sourceFuncData.globals?.[sourceVersion] || [],
                mnemonic_hash: sourceFuncData.mnemonic_hashes?.[sourceVersion] || '',
                indexes: sourceFuncData.indexes || {},
                instructions: sourceFuncData.instructions?.[sourceVersion] || [],
                tags: sourceFuncData.tags?.[sourceVersion] || [],
                instruction_count: sourceFuncData.instruction_counts?.[sourceVersion] || (sourceFuncData.instructions?.[sourceVersion]?.length || 0),
                loop_count: sourceFuncData.loop_counts?.[sourceVersion] || 0,
                stack_frame_size: sourceFuncData.stack_frame_sizes?.[sourceVersion] || 0,
                callee_count: sourceFuncData.callee_counts?.[sourceVersion] || (sourceFuncData.callees?.[sourceVersion]?.length || 0),
                caller_count: sourceFuncData.caller_counts?.[sourceVersion] || (sourceFuncData.callers?.[sourceVersion]?.length || 0),
                string_count: sourceStringCount,
                constant_count: sourceFuncData.constant_counts?.[sourceVersion] || (sourceFuncData.constants?.[sourceVersion]?.length || 0),
                global_count: sourceFuncData.global_counts?.[sourceVersion] || (sourceFuncData.globals?.[sourceVersion]?.length || 0),
                api_count: sourceFuncData.api_counts?.[sourceVersion] || 0,
                param_count: sourceParamCount
            };

            // Scan all functions with sequential filtering
            for (const [canonicalId, func] of Object.entries(currentFuncData.functions)) {
                const targetAddr = func.addresses?.[targetVersion];
                if (!targetAddr) continue; // No address in target version
                if (excludeAddress && targetAddr.toLowerCase() === excludeAddress.toLowerCase()) continue;

                // FILTER 1: Same number of parameters (must match exactly)
                const targetParamCount = func.param_counts?.[targetVersion] || 0;
                if (targetParamCount !== sourceParamCount) continue;

                // FILTER 2: Same calling convention
                const targetCallingConv = func.calling_convention || '';
                if (targetCallingConv !== sourceCallingConv) continue;

                // FILTER 3: Same number of string references
                const targetStringCount = func.string_counts?.[targetVersion] || (func.strings?.[targetVersion]?.length || 0);
                if (targetStringCount !== sourceStringCount) continue;

                // FILTER 4: Similar size (within 25% tolerance)
                const targetSize = func.sizes?.[targetVersion] || 0;
                if (sourceSize > 0 && targetSize > 0) {
                    const sizeRatio = Math.min(sourceSize, targetSize) / Math.max(sourceSize, targetSize);
                    if (sizeRatio < 0.75) continue;
                }

                // Build target object for full match calculation
                const targetObj = {
                    size: targetSize,
                    callees: func.callees?.[targetVersion] || [],
                    strings: func.strings?.[targetVersion] || [],
                    constants: func.constants?.[targetVersion] || [],
                    globals: func.globals?.[targetVersion] || [],
                    mnemonic_hash: func.mnemonic_hashes?.[targetVersion] || '',
                    indexes: func.indexes || {},
                    instructions: func.instructions?.[targetVersion] || [],
                    tags: func.tags?.[targetVersion] || [],
                    instruction_count: func.instruction_counts?.[targetVersion] || (func.instructions?.[targetVersion]?.length || 0),
                    loop_count: func.loop_counts?.[targetVersion] || 0,
                    stack_frame_size: func.stack_frame_sizes?.[targetVersion] || 0,
                    callee_count: func.callee_counts?.[targetVersion] || (func.callees?.[targetVersion]?.length || 0),
                    caller_count: func.caller_counts?.[targetVersion] || (func.callers?.[targetVersion]?.length || 0),
                    string_count: targetStringCount,
                    constant_count: func.constant_counts?.[targetVersion] || (func.constants?.[targetVersion]?.length || 0),
                    global_count: func.global_counts?.[targetVersion] || (func.globals?.[targetVersion]?.length || 0),
                    api_count: func.api_counts?.[targetVersion] || 0,
                    param_count: targetParamCount
                };

                // Calculate match score for candidates that pass all filters
                const match = calculateIdentityMatch(sourceObj, targetObj, sourceVersion, targetVersion);

                if (match.score > 20) { // Only consider if at least 20% match
                    alternates.push({
                        canonicalId,
                        address: targetAddr,
                        name: func.name || func.display_name || canonicalId,
                        score: match.score,
                        tier: match.tier,
                        tierName: match.tierName,
                        funcData: func
                    });
                }
            }

            // Sort by score descending and return top N
            alternates.sort((a, b) => b.score - a.score);
            return alternates.slice(0, topN);
        }

        // Build the complete comparison panel content
        function buildCompareContent(funcData, candidateFuncData, sourceVersion, targetVersion, identityMatch) {
            const targetData = candidateFuncData || funcData;

            // Extract all values for source
            const sourceSize = funcData.sizes?.[sourceVersion] || null;
            const sourceInstrCount = funcData.instructions?.[sourceVersion]?.length || 0;
            const sourceCalleeCount = funcData.callees?.[sourceVersion]?.length || 0;
            const sourceStringCount = funcData.strings?.[sourceVersion]?.length || 0;
            const sourceConstCount = funcData.constants?.[sourceVersion]?.length || 0;
            const sourceGlobalCount = funcData.globals?.[sourceVersion]?.length || 0;

            // Extract all values for target
            const targetSize = targetData.sizes?.[targetVersion] || null;
            const targetInstrCount = targetData.instructions?.[targetVersion]?.length || 0;
            const targetCalleeCount = targetData.callees?.[targetVersion]?.length || 0;
            const targetStringCount = targetData.strings?.[targetVersion]?.length || 0;
            const targetConstCount = targetData.constants?.[targetVersion]?.length || 0;
            const targetGlobalCount = targetData.globals?.[targetVersion]?.length || 0;

            // Build structural counts section (Size and Instructions only - other counts shown in section headers)
            const countsRows =
                renderCompareRow(sourceSize, 'Size (bytes)', targetSize, getMatchType(sourceSize, targetSize, 0.15)) +
                renderCompareRow(sourceInstrCount, 'Instructions', targetInstrCount, getMatchType(sourceInstrCount, targetInstrCount, 0.15));

            // Count matches for summary
            let matchedCounts = 0;
            if (sourceSize === targetSize) matchedCounts++;
            if (sourceInstrCount === targetInstrCount) matchedCounts++;

            // Get arrays for list sections
            const sourceCallees = funcData.callees?.[sourceVersion] || [];
            const targetCallees = targetData.callees?.[targetVersion] || [];
            const sourceCallers = funcData.callers?.[sourceVersion] || [];
            const targetCallers = targetData.callers?.[targetVersion] || [];
            const sourceStrings = funcData.strings?.[sourceVersion] || [];
            const targetStrings = targetData.strings?.[targetVersion] || [];
            const sourceConstants = funcData.constants?.[sourceVersion] || [];
            const targetConstants = targetData.constants?.[targetVersion] || [];
            const sourceGlobals = funcData.globals?.[sourceVersion] || [];
            const targetGlobals = targetData.globals?.[targetVersion] || [];
            const sourceTags = funcData.tags?.[sourceVersion] || [];
            const targetTags = targetData.tags?.[targetVersion] || [];

            // Get hashes
            const sourceMnemonicHash = funcData.mnemonic_hashes?.[sourceVersion] || '';
            const targetMnemonicHash = targetData.mnemonic_hashes?.[targetVersion] || '';

            // Build content
            let html = '';

            // Structural Counts - with score alongside counts summary
            const scoreInfo = identityMatch ? ` · ${identityMatch.score}%` : '';
            const countsSummaryWithScore = `<span class="match-count">${matchedCounts}</span>/2 exact${scoreInfo}`;
            html += renderCompareSection('Structural Counts', countsRows, countsSummaryWithScore, false);

            // Section 2: Mnemonic Hash
            html += renderCompareHashSection('Mnemonic Hash', sourceMnemonicHash, targetMnemonicHash, false);

            // Section 3: Signature
            html += renderCompareSignatureSection(funcData, targetData, false);

            // Section 4: Callees (match by function name)
            html += renderCompareListSection('Callees', sourceCallees, targetCallees, false, 'callees');

            // Section 5: Callers (match by function name)
            html += renderCompareListSection('Callers', sourceCallers, targetCallers, false, 'callers');

            // Section 6: Strings (match by value with path normalization)
            html += renderCompareListSection('String References', sourceStrings, targetStrings, false, 'strings');

            // Section 7: Constants (match by value)
            html += renderCompareListSection('Constants', sourceConstants, targetConstants, false, 'constants');

            // Section 8: Globals (match by name)
            html += renderCompareListSection('Global References', sourceGlobals, targetGlobals, false, 'globals');

            // Section 9: Tags
            html += renderCompareListSection('Function Tags', sourceTags, targetTags, false, 'default');

            return html;
        }

        // Highlight row and column for compare panel
        function highlightCompareCell(canonicalId, targetVersion) {
            // Clear any existing highlights
            clearCompareHighlights();

            const funcTable = document.getElementById('funcTableBody');
            if (!funcTable) return;

            // Find the row by matching the function name
            const funcData = currentFuncData?.functions?.[canonicalId];
            const funcName = funcData?.name || funcData?.display_name || canonicalId;

            const rows = funcTable.querySelectorAll('tr');
            for (const row of rows) {
                const nameCell = row.querySelector('.fn-name-cell .fn-name-text');
                if (nameCell && nameCell.textContent === funcName) {
                    row.classList.add('compare-active-row');

                    // Find the column index for targetVersion
                    const versionGroups = currentFuncData?.version_groups || [];
                    let colIndex = -1;
                    for (let i = 0; i < versionGroups.length; i++) {
                        if (versionGroups[i].versions.includes(targetVersion)) {
                            colIndex = i + 1; // +1 for the name column
                            break;
                        }
                    }

                    if (colIndex > 0) {
                        const cells = row.querySelectorAll('td');
                        if (cells[colIndex]) {
                            cells[colIndex].classList.add('compare-active-cell');
                        }

                        // Highlight column header
                        const headerRow = funcTable.closest('table')?.querySelector('thead tr');
                        if (headerRow) {
                            const headerCells = headerRow.querySelectorAll('th');
                            if (headerCells[colIndex]) {
                                headerCells[colIndex].classList.add('compare-active-column');
                            }
                        }
                    }
                    break;
                }
            }
        }

        // Clear compare panel highlights
        function clearCompareHighlights() {
            document.querySelectorAll('.compare-active-row').forEach(el => el.classList.remove('compare-active-row'));
            document.querySelectorAll('.compare-active-cell').forEach(el => el.classList.remove('compare-active-cell'));
            document.querySelectorAll('.compare-active-column').forEach(el => el.classList.remove('compare-active-column'));
        }

        // Show the compare panel with function data
        function showComparePanel(canonicalId, version, sourceVersion, isCandidate) {
            // If copyOnClick mode is enabled, copy address to clipboard instead
            if (copyOnClick) {
                const funcData = currentFuncData?.functions?.[canonicalId];
                let addr = funcData?.addresses?.[version];
                if (!addr && funcData?.candidates?.[version]) {
                    addr = funcData.candidates[version].address;
                }
                if (showRVA && funcData?.rvas?.[version]) {
                    addr = funcData.rvas[version];
                } else if (showRVA && funcData?.candidates?.[version]?.rva) {
                    addr = funcData.candidates[version].rva;
                }
                if (addr) {
                    navigator.clipboard.writeText(addr);
                    showToast('Address copied: ' + addr);
                } else {
                    showToast('No address to copy');
                }
                return;
            }

            const panel = document.getElementById('comparePanel');
            if (!panel) return;

            // Get function data
            const funcData = currentFuncData?.functions?.[canonicalId];
            if (!funcData) {
                showToast('Function data not available');
                return;
            }

            // Store current comparison data
            currentComparisonData = {
                canonicalId,
                targetVersion: version,
                sourceVersion: sourceVersion,
                isCandidate
            };

            // Get addresses
            const sourceAddr = funcData.addresses?.[sourceVersion] || '—';
            let targetAddr = funcData.addresses?.[version];
            let candidate = null;
            let candidateFuncData = null;

            if (!targetAddr && funcData.candidates?.[version]) {
                candidate = funcData.candidates[version];
                targetAddr = candidate.address;

                // Look up the actual function data for the candidate by its address
                const matchedFunc = findFunctionByAddress(candidate.address, version);
                if (matchedFunc) {
                    candidateFuncData = matchedFunc.func;
                }
            }

            // Build source and target objects for identity matching
            const targetData = candidateFuncData || funcData;
            const sourceObj = {
                size: funcData.sizes?.[sourceVersion],
                callees: funcData.callees?.[sourceVersion] || [],
                strings: funcData.strings?.[sourceVersion] || [],
                constants: funcData.constants?.[sourceVersion] || [],
                globals: funcData.globals?.[sourceVersion] || [],
                mnemonic_hash: funcData.mnemonic_hashes?.[sourceVersion] || '',
                indexes: funcData.indexes || parseIndexToObject(funcData.index),
                loop_count: funcData.loop_counts?.[sourceVersion],
                stack_frame: funcData.stack_frame_sizes?.[sourceVersion] || 0,
                instructions: funcData.instructions?.[sourceVersion] || []
            };
            const targetObj = {
                size: targetData.sizes?.[version],
                callees: targetData.callees?.[version] || [],
                strings: targetData.strings?.[version] || [],
                constants: targetData.constants?.[version] || [],
                globals: targetData.globals?.[version] || [],
                mnemonic_hash: targetData.mnemonic_hashes?.[version] || '',
                indexes: targetData.indexes || parseIndexToObject(targetData.index),
                loop_count: targetData.loop_counts?.[version],
                stack_frame: targetData.stack_frame_sizes?.[version] || 0,
                instructions: targetData.instructions?.[version] || []
            };

            // Calculate identity match score
            let identityMatch = calculateIdentityMatch(sourceObj, targetObj, sourceVersion, version);
            let overallScore = identityMatch.score;

            // For candidates, check if any alternate has a higher score and swap if so
            if (candidate) {
                const alternates = findTopAlternateMatches(funcData, sourceVersion, version, 5, null);
                const betterAlt = alternates.find(alt => alt.score > overallScore);
                if (betterAlt) {
                    // Swap: use the better alternate as the main candidate
                    const betterMatchedFunc = findFunctionByAddress(betterAlt.address, version);
                    if (betterMatchedFunc) {
                        candidateFuncData = betterMatchedFunc.func;
                        targetAddr = betterAlt.address;
                        candidate = {
                            ...candidate,
                            address: betterAlt.address,
                            matched_to: betterAlt.name
                        };
                        // Recalculate identity match with the better candidate
                        const newTargetObj = {
                            size: candidateFuncData.sizes?.[version],
                            callees: candidateFuncData.callees?.[version] || [],
                            strings: candidateFuncData.strings?.[version] || [],
                            constants: candidateFuncData.constants?.[version] || [],
                            globals: candidateFuncData.globals?.[version] || [],
                            mnemonic_hash: candidateFuncData.mnemonic_hashes?.[version] || '',
                            indexes: candidateFuncData.indexes || parseIndexToObject(candidateFuncData.index),
                            loop_count: candidateFuncData.loop_counts?.[version],
                            stack_frame: candidateFuncData.stack_frame_sizes?.[version] || 0,
                            instructions: candidateFuncData.instructions?.[version] || []
                        };
                        identityMatch = calculateIdentityMatch(sourceObj, newTargetObj, sourceVersion, version);
                        overallScore = identityMatch.score;
                    }
                }
            }

            // Update panel title
            document.getElementById('comparePanelTitle').textContent = 'Compare Functions';

            // Build header info
            const funcName = funcData.name || funcData.display_name || canonicalId;
            const isKnown = funcData.name && !funcData.name.startsWith('FUN_');
            const knownBadge = isKnown ? '<span class="known-badge">Known</span>' : '';
            const candidateName = candidateFuncData?.name || candidate?.matched_to || '';
            const candidateNameDisplay = candidate && candidateName ? ` → ${candidateName}` : '';

            const scoreClass = overallScore >= 80 ? 'high' : overallScore >= 50 ? 'medium' : 'low';
            const tierIcon = { 1: '🔒', 2: '🎯', 3: '⚖️' }[identityMatch.tier] || '';

            const headerHtml = `
                <div class="compare-func-name">${escapeHtml(funcName)}${knownBadge}${candidateNameDisplay}</div>
                <div class="compare-versions">
                    <div class="compare-version-info source">
                        <div class="compare-version-label">Source</div>
                        <div class="compare-version-value">${sourceVersion}<br>${sourceAddr}</div>
                    </div>
                    <div class="compare-score">
                        <div class="compare-score-value ${scoreClass}">${tierIcon} ${overallScore}%</div>
                        <div class="compare-score-tier">${identityMatch.tierName}</div>
                    </div>
                    <div class="compare-version-info target">
                        <div class="compare-version-label">${candidate ? 'Candidate' : 'Target'}</div>
                        <div class="compare-version-value">${version}<br>${targetAddr || '—'}</div>
                    </div>
                </div>
            `;

            document.getElementById('compareHeaderInfo').innerHTML = headerHtml;

            // Find and display alternate matches (only for candidates)
            let alternateMatchesHtml = '';
            if (candidate) {
                const currentAddr = targetAddr;
                const alternates = findTopAlternateMatches(funcData, sourceVersion, version, 3, currentAddr);

                if (alternates.length > 0) {
                    alternateMatchesHtml = `
                        <div class="alternate-matches">
                            <span class="alternate-label">Alternate Matches:</span>
                            <div class="alternate-buttons">
                    `;

                    for (const alt of alternates) {
                        const altScoreClass = alt.score >= 70 ? 'high' : alt.score >= 40 ? 'medium' : 'low';
                        const altName = alt.name.length > 20 ? alt.name.substring(0, 17) + '...' : alt.name;
                        alternateMatchesHtml += `
                            <button class="alternate-match-btn"
                                    onclick="selectAlternateMatch('${canonicalId}', '${version}', '${sourceVersion}', '${alt.canonicalId}', '${alt.address}')"
                                    title="${alt.name}&#10;Address: ${alt.address}&#10;Score: ${alt.score}%">
                                <span class="alt-name">${escapeHtml(altName)}</span>
                                <span class="alt-score ${altScoreClass}">${alt.score}%</span>
                            </button>
                        `;
                    }

                    alternateMatchesHtml += `
                            </div>
                        </div>
                    `;
                }
            }

            // Build content
            const contentHtml = (alternateMatchesHtml ? alternateMatchesHtml : '') +
                buildCompareContent(funcData, candidateFuncData, sourceVersion, version, identityMatch);
            document.getElementById('compareContent').innerHTML = contentHtml;

            // Show/hide action buttons based on whether it's a candidate
            const actionsDiv = document.getElementById('compareActions');
            if (candidate) {
                const status = getMatchStatus(canonicalId, version, targetAddr);
                document.getElementById('compareBtnConfirm').style.display = status !== 'confirmed' ? 'block' : 'none';
                document.getElementById('compareBtnReject').style.display = status !== 'rejected' ? 'block' : 'none';
                actionsDiv.classList.remove('hidden');
            } else {
                actionsDiv.classList.add('hidden');
            }

            // Show panel
            panel.classList.add('visible');

            // Highlight the row and column in the table
            highlightCompareCell(canonicalId, version);
        }

        // Close the compare panel
        function closeComparePanel() {
            const panel = document.getElementById('comparePanel');
            if (panel) {
                panel.classList.remove('visible');
            }
            currentComparisonData = null;
            clearCompareHighlights();
        }

        // Select an alternate match and update the compare panel
        function selectAlternateMatch(sourceCanonicalId, targetVersion, sourceVersion, altCanonicalId, altAddress) {
            // Show compare panel with the alternate function as target
            // We need to show the source function compared against the alternate target function
            const sourceFuncData = currentFuncData?.functions?.[sourceCanonicalId];
            const altFuncData = currentFuncData?.functions?.[altCanonicalId];

            if (!sourceFuncData || !altFuncData) {
                showToast('Function data not available');
                return;
            }

            const panel = document.getElementById('comparePanel');
            if (!panel) return;

            // Store current comparison data with alternate
            currentComparisonData = {
                canonicalId: sourceCanonicalId,
                targetVersion: targetVersion,
                sourceVersion: sourceVersion,
                isCandidate: true,
                alternateCanonicalId: altCanonicalId,
                alternateAddress: altAddress
            };

            // Get addresses
            const sourceAddr = sourceFuncData.addresses?.[sourceVersion] || '—';
            const targetAddr = altAddress;

            // Build source and target objects for identity matching
            const sourceObj = {
                size: sourceFuncData.sizes?.[sourceVersion],
                callees: sourceFuncData.callees?.[sourceVersion] || [],
                strings: sourceFuncData.strings?.[sourceVersion] || [],
                constants: sourceFuncData.constants?.[sourceVersion] || [],
                globals: sourceFuncData.globals?.[sourceVersion] || [],
                mnemonic_hash: sourceFuncData.mnemonic_hashes?.[sourceVersion] || '',
                indexes: sourceFuncData.indexes || parseIndexToObject(sourceFuncData.index),
                loop_count: sourceFuncData.loop_counts?.[sourceVersion],
                stack_frame: sourceFuncData.stack_frame_sizes?.[sourceVersion] || 0,
                instructions: sourceFuncData.instructions?.[sourceVersion] || [],
                instruction_count: sourceFuncData.instruction_counts?.[sourceVersion] || (sourceFuncData.instructions?.[sourceVersion]?.length || 0),
                callee_count: sourceFuncData.callee_counts?.[sourceVersion] || (sourceFuncData.callees?.[sourceVersion]?.length || 0),
                caller_count: sourceFuncData.caller_counts?.[sourceVersion] || (sourceFuncData.callers?.[sourceVersion]?.length || 0),
                string_count: sourceFuncData.string_counts?.[sourceVersion] || (sourceFuncData.strings?.[sourceVersion]?.length || 0),
                constant_count: sourceFuncData.constant_counts?.[sourceVersion] || (sourceFuncData.constants?.[sourceVersion]?.length || 0),
                global_count: sourceFuncData.global_counts?.[sourceVersion] || (sourceFuncData.globals?.[sourceVersion]?.length || 0),
                api_count: sourceFuncData.api_counts?.[sourceVersion] || 0,
                param_count: sourceFuncData.param_counts?.[sourceVersion] || 0
            };
            const targetObj = {
                size: altFuncData.sizes?.[targetVersion],
                callees: altFuncData.callees?.[targetVersion] || [],
                strings: altFuncData.strings?.[targetVersion] || [],
                constants: altFuncData.constants?.[targetVersion] || [],
                globals: altFuncData.globals?.[targetVersion] || [],
                mnemonic_hash: altFuncData.mnemonic_hashes?.[targetVersion] || '',
                indexes: altFuncData.indexes || parseIndexToObject(altFuncData.index),
                loop_count: altFuncData.loop_counts?.[targetVersion],
                stack_frame: altFuncData.stack_frame_sizes?.[targetVersion] || 0,
                instructions: altFuncData.instructions?.[targetVersion] || [],
                instruction_count: altFuncData.instruction_counts?.[targetVersion] || (altFuncData.instructions?.[targetVersion]?.length || 0),
                callee_count: altFuncData.callee_counts?.[targetVersion] || (altFuncData.callees?.[targetVersion]?.length || 0),
                caller_count: altFuncData.caller_counts?.[targetVersion] || (altFuncData.callers?.[targetVersion]?.length || 0),
                string_count: altFuncData.string_counts?.[targetVersion] || (altFuncData.strings?.[targetVersion]?.length || 0),
                constant_count: altFuncData.constant_counts?.[targetVersion] || (altFuncData.constants?.[targetVersion]?.length || 0),
                global_count: altFuncData.global_counts?.[targetVersion] || (altFuncData.globals?.[targetVersion]?.length || 0),
                api_count: altFuncData.api_counts?.[targetVersion] || 0,
                param_count: altFuncData.param_counts?.[targetVersion] || 0
            };

            // Calculate identity match score
            const identityMatch = calculateIdentityMatch(sourceObj, targetObj, sourceVersion, targetVersion);
            const overallScore = identityMatch.score;

            // Update panel title
            document.getElementById('comparePanelTitle').textContent = 'Compare Functions (Alternate)';

            // Build header info
            const sourceFuncName = sourceFuncData.name || sourceFuncData.display_name || sourceCanonicalId;
            const altFuncName = altFuncData.name || altFuncData.display_name || altCanonicalId;
            const isKnown = sourceFuncData.name && !sourceFuncData.name.startsWith('FUN_');
            const knownBadge = isKnown ? '<span class="known-badge">Known</span>' : '';

            const scoreClass = overallScore >= 80 ? 'high' : overallScore >= 50 ? 'medium' : 'low';
            const tierIcon = { 1: '🔒', 2: '🎯', 3: '⚖️' }[identityMatch.tier] || '';

            const headerHtml = `
                <div class="compare-func-name">${escapeHtml(sourceFuncName)}${knownBadge} → ${escapeHtml(altFuncName)}</div>
                <div class="compare-versions">
                    <div class="compare-version-info source">
                        <div class="compare-version-label">Source</div>
                        <div class="compare-version-value">${sourceVersion}<br>${sourceAddr}</div>
                    </div>
                    <div class="compare-score">
                        <div class="compare-score-value ${scoreClass}">${tierIcon} ${overallScore}%</div>
                        <div class="compare-score-tier">${identityMatch.tierName}</div>
                    </div>
                    <div class="compare-version-info target">
                        <div class="compare-version-label">Alternate</div>
                        <div class="compare-version-value">${targetVersion}<br>${targetAddr}</div>
                    </div>
                </div>
            `;

            document.getElementById('compareHeaderInfo').innerHTML = headerHtml;

            // Find other alternates (excluding current alternate)
            const alternates = findTopAlternateMatches(sourceFuncData, sourceVersion, targetVersion, 3, altAddress);

            let alternateMatchesHtml = '';
            if (alternates.length > 0) {
                alternateMatchesHtml = `
                    <div class="alternate-matches">
                        <span class="alternate-label">Other Alternates:</span>
                        <div class="alternate-buttons">
                `;

                for (const alt of alternates) {
                    const altScoreClass = alt.score >= 70 ? 'high' : alt.score >= 40 ? 'medium' : 'low';
                    const altDisplayName = alt.name.length > 20 ? alt.name.substring(0, 17) + '...' : alt.name;
                    const isSelected = alt.canonicalId === altCanonicalId;
                    alternateMatchesHtml += `
                        <button class="alternate-match-btn ${isSelected ? 'selected' : ''}"
                                onclick="selectAlternateMatch('${sourceCanonicalId}', '${targetVersion}', '${sourceVersion}', '${alt.canonicalId}', '${alt.address}')"
                                title="${alt.name}&#10;Address: ${alt.address}&#10;Score: ${alt.score}%">
                            <span class="alt-name">${escapeHtml(altDisplayName)}</span>
                            <span class="alt-score ${altScoreClass}">${alt.score}%</span>
                        </button>
                    `;
                }

                alternateMatchesHtml += `
                        </div>
                    </div>
                `;
            }

            // Build content
            const contentHtml = (alternateMatchesHtml ? alternateMatchesHtml : '') +
                buildCompareContent(sourceFuncData, altFuncData, sourceVersion, targetVersion, identityMatch);
            document.getElementById('compareContent').innerHTML = contentHtml;

            // Hide action buttons for alternates (they're for exploration only)
            const actionsDiv = document.getElementById('compareActions');
            actionsDiv.classList.add('hidden');

            // Show panel
            panel.classList.add('visible');

            // Highlight the source row and target column in the table
            highlightCompareCell(sourceCanonicalId, targetVersion);
        }

        // Update compare panel if visible (e.g., after data changes)
        function updateComparePanel() {
            if (!currentComparisonData) return;
            const panel = document.getElementById('comparePanel');
            if (panel && panel.classList.contains('visible')) {
                showComparePanel(
                    currentComparisonData.canonicalId,
                    currentComparisonData.targetVersion,
                    currentComparisonData.sourceVersion,
                    currentComparisonData.isCandidate
                );
            }
        }

        // Confirm match
        function confirmMatch() {
            if (!currentComparisonData) return;

            const { canonicalId, targetVersion } = currentComparisonData;
            const funcData = currentFuncData?.functions?.[canonicalId];
            const candidate = funcData?.candidates?.[targetVersion];

            if (candidate) {
                saveMatchDecision(canonicalId, targetVersion, candidate.address, true);
                showToast('Match confirmed! This will be treated as confirmed in the viewer.');
                closeComparePanel();
                updateFunctionsTableBody();
            }
        }

        // Reject match
        function rejectMatch() {
            if (!currentComparisonData) return;

            const { canonicalId, targetVersion } = currentComparisonData;
            const funcData = currentFuncData?.functions?.[canonicalId];
            const candidate = funcData?.candidates?.[targetVersion];

            if (candidate) {
                saveMatchDecision(canonicalId, targetVersion, candidate.address, false);
                showToast('Match rejected. Looking for next best match...');
                closeComparePanel();
                updateFunctionsTableBody();
            }
        }

        // Get candidate for cell, considering rejected matches
        function getCandidateForCell(func, version) {
            const candidate = func.candidates?.[version];
            if (!candidate) return null;

            const status = getMatchStatus(func.name || '', version, candidate.address);
            return {
                ...candidate,
                status
            };
        }

        // Format cell content with click handler
        function formatAddressCell(func, canonicalId, version, sourceVersion) {
            const addr = func.addresses?.[version];
            const rva = showRVA && func.rvas?.[version] ? func.rvas[version] : null;
            const displayAddr = rva || addr;

            if (displayAddr) {
                // Confirmed address - clickable for comparison
                return `<td class="addr-cell" onclick="showComparePanel('${canonicalId}', '${version}', '${sourceVersion}', false)" style="cursor:pointer;" title="Click to compare">${displayAddr}</td>`;
            }

            // Check for candidate
            const candidate = func.candidates?.[version];
            if (candidate) {
                const status = getMatchStatus(canonicalId, version, candidate.address);
                const candAddr = showRVA && candidate.rva ? candidate.rva : candidate.address;
                const confidence = candidate.confidence || 0;

                let cellClass = 'addr-cell candidate';
                if (status === 'confirmed') {
                    cellClass = 'addr-cell confirmed';
                } else if (status === 'rejected') {
                    cellClass = 'addr-cell rejected';
                } else if (confidence >= 0.8) {
                    cellClass = 'addr-cell candidate candidate-high';
                } else if (confidence < 0.6) {
                    cellClass = 'addr-cell candidate candidate-low';
                }

                const confidenceTitle = `Candidate (${(confidence * 100).toFixed(0)}% confidence, ${candidate.method})`;

                // Use sourceVersion parameter instead of candidate.source
                return `<td class="${cellClass}" onclick="showComparePanel('${canonicalId}', '${version}', '${sourceVersion}', true)" title="${confidenceTitle}">${candAddr}</td>`;
            }

            // Empty cell
            return '<td class="addr-cell missing">—</td>';
        }
    </script>
</body>

</html>